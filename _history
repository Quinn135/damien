{"entries":[{"timestamp":1738802832710,"editorVersion":"7.0.57","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[-1,"let ledOn = false;\nlet brightness = 0;\nlet t = input.runningTimeMicros();\n\nwhile (true){\n    input.runningTimeMicros()\n    serial.writeLine(brightness.toString());\n    \n    if (input.buttonIsPressed(Button.A)){\n        ledOn = true;\n\n        brightness++;\n        led.plotBrightness(2, 2, brightness);\n    } else if (input.buttonIsPressed(Button.B) && ledOn){\n        ledOn = false;\n        led.unplot(2, 2);\n    }\n}"],[1,"\n"]],"start1":0,"start2":0,"length1":416,"length2":1}]},{"type":"edited","filename":"pxt.json","patch":[{"diffs":[[0,"pt-only\""],[1,",\n    \"additionalFilePaths\": []"],[0,"\n}\n"]],"start1":274,"start2":274,"length1":11,"length2":42}]}]},{"timestamp":1738803420941,"editorVersion":"7.0.57","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[1,"let ledOn = false;\n"],[0,"let brightne"]],"start1":0,"start2":0,"length1":12,"length2":31},{"diffs":[[0,"    "],[-1,"brightness = Math.min(255, brightness + 1); // max to 255"],[1,"ledOn = true;\n\n        brightness++;\n        led.plotBrightness(2, 2, brightness);"],[0,"\n   "]],"start1":215,"start2":215,"length1":65,"length2":90},{"diffs":[[0,"utton.B)"],[1," && ledOn"],[0,"){\n     "]],"start1":340,"start2":340,"length1":16,"length2":25},{"diffs":[[0,"    "],[-1,"brightness = Math.max(0, brightness - 1); // max to 255"],[1,"ledOn = false;"],[0,"\n    "],[-1,"}\n\n"],[0,"    led."],[1,"un"],[0,"plot"],[-1,"Brightness(2, 2, brightness"],[1,"(2, 2"],[0,");\n"],[-1,"\n"],[0,"    "],[-1,"control.waitMicros(1000000 / 20);"],[1,"}"],[0,"\n}"]],"start1":364,"start2":364,"length1":149,"length2":52}]}]},{"timestamp":1738803965810,"editorVersion":"7.0.57","changes":[{"type":"edited","filename":"pxt.json","patch":[{"diffs":[[0," \"*\""],[-1,",\n        \"k8\": \"github:k8robotics/pxt-k8#v1.1.0\""],[0,"\n   "]],"start1":133,"start2":133,"length1":57,"length2":8}]}]},{"timestamp":1738804156712,"editorVersion":"7.0.57","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0," 0;\nlet "],[-1,"lastTime"],[1,"t"],[0," = input"]],"start1":16,"start2":16,"length1":24,"length2":17},{"diffs":[[0,"os()"],[-1," / 1000000;\nlet time = lastTime + 1 / 60;\n\nwhile (true){\n    serial.writeLine(brightness.toString());\n    \n    brightness = Math.min(255, Math.max(0, sonar.checkSonar() / 150 * 255));\n\n    led.plotBrightness(2, 2, brightness);\n\n    time = input.runningTimeMicros() / 1000000; // Update time\n    //"],[1,";\n\nwhile (true){\n    input.runningTimeMicros()\n    serial.writeLine(brightness.toString());\n    \n    if (input.buttonIsPressed(Button.A)){\n        brightness = Math.min(255, brightness + 1); // max to 255\n    } else if (input.buttonIsPressed(Button.B)){\n        brightness = Math.max(0, brightness - 1); // max to 255\n    }\n\n    led.plotBrightness(2, 2, brightness);\n\n   "],[0," con"]],"start1":49,"start2":49,"length1":305,"length2":379}]}]},{"timestamp":1738804695113,"editorVersion":"7.0.57","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"ue){\n   "],[-1," //"],[0," serial."]],"start1":112,"start2":112,"length1":19,"length2":16},{"diffs":[[0,"ng()"],[-1," + \", \" + time.toString()"],[0,");\n "]],"start1":155,"start2":155,"length1":33,"length2":8},{"diffs":[[0,"    \n   "],[-1," //"],[0," brightn"]],"start1":162,"start2":162,"length1":19,"length2":16},{"diffs":[[0,", sonar."],[1,"checkSonar()"],[0," / 150 *"]],"start1":208,"start2":208,"length1":16,"length2":28},{"diffs":[[0,"));\n\n   "],[-1," //"],[0," led.plo"]],"start1":240,"start2":240,"length1":19,"length2":16},{"diffs":[[0,"s);\n\n   "],[-1," //"],[0," time = "]],"start1":283,"start2":283,"length1":19,"length2":16},{"diffs":[[0,"0);\n"],[-1,"\n    serial.writeLine(sonar.checkSonar().toString());\n}\n\n"],[1,"}"]],"start1":388,"start2":388,"length1":61,"length2":5}]}]},{"timestamp":1738805177194,"editorVersion":"7.0.57","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0," / 20);\n\n   "],[-1," //"],[0," serial.writ"]],"start1":409,"start2":409,"length1":27,"length2":24}]}]},{"timestamp":1738807868016,"editorVersion":"7.0.57","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"));\n"],[-1,"    sonar.\n"],[0,"}\n\n"]],"start1":470,"start2":470,"length1":18,"length2":7}]}]},{"timestamp":1738807870838,"editorVersion":"7.0.57","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"nar."],[-1,"displaySonar();\n    control.waitMicros(1000000/40);"],[0,"\n}\n\n"]],"start1":480,"start2":480,"length1":59,"length2":8}]}]},{"timestamp":1738807890762,"editorVersion":"7.0.57","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"te time\n"],[1,"    // control.waitMicros(1000000 / 20);\n\n    // serial.writeLine(sonar.checkSonar().toString());\n    sonar.displaySonar();\n"],[0,"    cont"]],"start1":368,"start2":368,"length1":16,"length2":140}]}]},{"timestamp":1738809499931,"editorVersion":"7.0.57","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"50 * 255));\n"],[1,"\n"],[0,"    // led.p"]],"start1":251,"start2":251,"length1":24,"length2":25}]}]},{"timestamp":1738809506720,"editorVersion":"7.0.57","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[-1,"// "],[0,"let brig"]],"start1":0,"start2":0,"length1":11,"length2":8},{"diffs":[[0,"0;\n\n"],[-1,"const targetFPS = 30;\n\nwhile (true){\n    time = input.runningTimeMicros() / 1000000; // Update time\n    serial.writeLine((1 / (time - lastT"],[1,"while (true){\n    // serial.writeLine(brightness.toString() + \", \" + t"],[0,"ime"],[-1,"))"],[0,".toS"]],"start1":99,"start2":99,"length1":152,"length2":81},{"diffs":[[0,"tring())"],[-1,"\n"],[1,";\n    "],[0,"\n    // "]],"start1":180,"start2":180,"length1":17,"length2":22},{"diffs":[[0,"    "],[-1,"let tempTime = lastTime;\n    lastTime ="],[1,"// time = input.runningTimeMicros() / 1000000; // Update"],[0," time"],[-1,";"],[0,"\n   "]],"start1":309,"start2":309,"length1":53,"length2":69},{"diffs":[[0,"ros("],[-1,"Math.max(0, 1000000 / targetFPS - (time - lastTime) * 1000000)"],[1,"1000000/40"],[0,");\n}"]],"start1":394,"start2":394,"length1":70,"length2":18}]}]},{"timestamp":1738809968515,"editorVersion":"7.0.57","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0," = 30;\n\n"],[-1,"\n\n"],[0,"while (t"]],"start1":121,"start2":121,"length1":18,"length2":16},{"diffs":[[0,"time\n   "],[-1," //"],[0," serial."]],"start1":201,"start2":201,"length1":19,"length2":16},{"diffs":[[0,"g())"],[-1,"\n    serial.writeLine((Math.cos(time) * 100).toString());"],[0,"\n\n  "]],"start1":258,"start2":258,"length1":65,"length2":8},{"diffs":[[0,"ss);"],[-1,"\n    // motion.drive(Math.cos(time) * 100, Math.cos(time + Math.PI/2) * 100);"],[0,"\n\n  "]],"start1":372,"start2":372,"length1":85,"length2":8}]}]},{"timestamp":1738810506900,"editorVersion":"7.0.57","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"0;\n\n"],[-1,"let leftWheelSpeed = 0;\nlet rightWheelSpeed = 0;"],[0,"\n\nwh"]],"start1":125,"start2":125,"length1":56,"length2":8},{"diffs":[[0,"ime\n"],[-1,"\n"],[0,"    "],[-1,"if (input.buttonIsPressed(Button.A)){\n        leftWheelSpeed = 0.5;\n "],[1,"// serial.writeLine((1 / (time - lastTime)).toString())\n    serial.writeLine((Math.cos(time) * 100).toString());\n\n"],[0,"    "],[-1,"   "],[1,"// b"],[0,"right"],[-1,"WheelSpeed = leftWheelSpeed;\n    } else {\n        if (input.buttonIsPressed(Button.B)) {\n   "],[1,"ness = Math.min(255, Math.max(0, sonar. / 150 * 255));\n"],[0,"    "],[1,"//"],[0," le"],[-1,"ftWheelSpeed = -0.5;\n    }\n   \n    motion.driveWheel(Motor.LEFT, -leftWheelSpeed * 100);\n    motion.driveWheel(Motor.RIGHT, -rightWheelSpeed"],[1,"d.plotBrightness(2, 2, brightness);\n    // motion.drive(Math.cos(time) * 100, Math.cos(time + Math.PI/2)"],[0," * 1"]],"start1":204,"start2":204,"length1":333,"length2":307}]}]},{"timestamp":1738811106736,"editorVersion":"7.0.57","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"    "],[-1,"servos.setLeftServoPosition(90);\n\n    // Stuff that should run every time"],[1,"if (input.buttonIsPressed(Button.A)){\n        leftWheelSpeed = 0.5;\n        rightWheelSpeed = leftWheelSpeed;\n    } else {\n        if (input.buttonIsPressed(Button.B)) {\n        leftWheelSpeed = -0.5;\n    }\n   "],[0,"\n   "]],"start1":257,"start2":257,"length1":81,"length2":218},{"diffs":[[0,"r.LEFT, "],[1,"-"],[0,"leftWhee"]],"start1":498,"start2":498,"length1":16,"length2":17},{"diffs":[[0,".RIGHT, "],[1,"-"],[0,"rightWhe"]],"start1":557,"start2":557,"length1":16,"length2":17}]}]},{"timestamp":1738811675628,"editorVersion":"7.0.57","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"vos."],[-1,"re"],[0,"set"],[-1,"Servos("],[1,"LeftServoPosition(90"],[0,");\n\n"]],"start1":264,"start2":264,"length1":20,"length2":31}]}]},{"timestamp":1738811814698,"editorVersion":"7.0.57","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"me\n\n    "],[1,"servos.resetServos();"],[0,"\n\n    //"]],"start1":253,"start2":253,"length1":16,"length2":37}]}]},{"timestamp":1738812828504,"editorVersion":"7.0.57","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"    "],[-1,"input.compassHeading()"],[0,"\n\n  "]],"start1":257,"start2":257,"length1":30,"length2":8}]}]},{"timestamp":1738812891807,"editorVersion":"7.0.57","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"S = "],[-1,"15"],[1,"3"],[0,"0;\n\n"]],"start1":120,"start2":120,"length1":10,"length2":9},{"diffs":[[0,"0;\n\n"],[-1,"let heading = 0;\n\n"],[0,"whil"]],"start1":175,"start2":175,"length1":26,"length2":8},{"diffs":[[0,"\n   "],[-1," heading ="],[0," inp"]],"start1":256,"start2":256,"length1":18,"length2":8},{"diffs":[[0,"ng()"],[-1," / 180 * Math.PI; // radians\n\n    if (heading > Math.PI / 2){\n        leftWheelSpeed = 0.2;\n        rightWheelSpeed = -0.2;\n    }\n    if (heading < Math.PI / 2) {\n        leftWheelSpeed = -0.2;\n        rightWheelSpeed = 0.2;\n    }"],[0,"\n\n  "]],"start1":279,"start2":279,"length1":238,"length2":8}]}]},{"timestamp":1738813468786,"editorVersion":"7.0.57","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"    "],[-1,"let diff = "],[1,"if ("],[0,"heading "],[-1,"-"],[1,">"],[0," Mat"]],"start1":342,"start2":342,"length1":28,"length2":21},{"diffs":[[0," / 2"],[-1,";\n    let multiplier = (Math.abs(diff) / Math.PI + 0.05)\n    if (diff > 0"],[0,"){\n "]],"start1":367,"start2":367,"length1":81,"length2":8},{"diffs":[[0,"elSpeed = 0."],[-1,"1 * multiplier"],[1,"2"],[0,";\n        ri"]],"start1":389,"start2":389,"length1":38,"length2":25},{"diffs":[[0,"lSpeed = -0."],[-1,"1 * multiplier"],[1,"2"],[0,";\n    }\n    "]],"start1":421,"start2":421,"length1":38,"length2":25},{"diffs":[[0,"if ("],[-1,"diff < 0"],[1,"heading < Math.PI / 2"],[0,") {\n"]],"start1":446,"start2":446,"length1":16,"length2":29},{"diffs":[[0,"ed = -0."],[-1,"1 * multiplier"],[1,"2"],[0,";\n      "]],"start1":495,"start2":495,"length1":30,"length2":17},{"diffs":[[0,"= 0."],[-1,"1 * multiplier"],[1,"2"],[0,";\n  "]],"start1":530,"start2":530,"length1":22,"length2":9}]}]},{"timestamp":1738813715193,"editorVersion":"7.0.57","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"etFPS = "],[-1,"2"],[1,"150"],[0,";\n\nlet l"]],"start1":116,"start2":116,"length1":17,"length2":19}]}]},{"timestamp":1738879835779,"editorVersion":"7.0.57","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0," Math.PI"],[1," + 0.05"],[0,")\n    if"]],"start1":416,"start2":416,"length1":16,"length2":23}]}]},{"timestamp":1738879842500,"editorVersion":"7.0.57","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"tWheelSpeed = 0."],[-1,"05"],[1,"1"],[0," * multiplier;\n "]],"start1":456,"start2":456,"length1":34,"length2":33},{"diffs":[[0,"WheelSpeed = -0."],[-1,"05"],[1,"1"],[0," * multiplier;\n "]],"start1":501,"start2":501,"length1":34,"length2":33},{"diffs":[[0,"ed = -0."],[-1,"05"],[1,"1"],[0," * multi"]],"start1":579,"start2":579,"length1":18,"length2":17},{"diffs":[[0,"= 0."],[-1,"05"],[1,"1"],[0," * m"]],"start1":627,"start2":627,"length1":10,"length2":9},{"diffs":[[0,"rive"],[-1,"(Math.cos(time / 5) * 100, Math.cos(time / 5) * 100);\n    // motion.drive(leftWheelSpeed, rightWheelSpeed);\n    serial.writeLine(diff.toString() + \", \" + leftWheelSpeed.toString() + \", \" +"],[1,"Wheel(Motor.LEFT, leftWheelSpeed * 100);\n    motion.driveWheel(Motor.RIGHT,"],[0," rig"]],"start1":706,"start2":706,"length1":196,"length2":83},{"diffs":[[0,"peed"],[-1,".toString()"],[1," * 100"],[0,");\n\n"]],"start1":797,"start2":797,"length1":19,"length2":14}]}]},{"timestamp":1738880436638,"editorVersion":"7.0.57","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0," = 2"],[-1,"5"],[0,";\n\nl"]],"start1":121,"start2":121,"length1":9,"length2":8},{"diffs":[[0,"0;\n\n"],[-1,"// if going backwards, speed is just regular out of 100, minus 100\n// so 20 backwards is -80\n// 80 backwards is -20\n\nwhile (true){\n    time = input.runningTimeMicros() / 1000000; // Update time\n\n    if (input.buttonIsPressed(Button.A) && !input.buttonIsPressed(Button.B)"],[1,"while (true){\n    time = input.runningTimeMicros() / 1000000; // Update time\n\n    heading = input.compassHeading() / 180 * Math.PI; // radians\n\n    let diff = heading - Math.PI / 2;\n    let multiplier = (Math.abs(diff) / Math.PI)\n    if (diff > 0"],[0,"){\n "]],"start1":192,"start2":192,"length1":278,"length2":254},{"diffs":[[0,"elSpeed = 0."],[-1,"1"],[1,"05 * multiplier"],[0,";\n        ri"]],"start1":460,"start2":460,"length1":25,"length2":39},{"diffs":[[0," -0."],[-1,"1;\n    } else if (input.buttonIsPressed(Button.B))"],[1,"05 * multiplier;\n    }\n    if (diff < 0) "],[0,"{\n  "]],"start1":514,"start2":514,"length1":58,"length2":49},{"diffs":[[0,"ed = -0."],[-1,"1"],[1,"05 * multiplier"],[0,";\n      "]],"start1":581,"start2":581,"length1":17,"length2":31},{"diffs":[[0,"= 0."],[-1,"1;\n    } else {\n        leftWheelSpeed = 0;\n        rightWheelSpeed = 0;\n    }\n\n    "],[1,"05 * multiplier;\n    }\n\n    // Stuff that should run every time\n    motion.drive(Math.cos(time / 5) * 100, Math.cos(time / 5) * 100);\n    // motion.drive(leftWheelSpeed, rightWheelSpeed);\n    serial.writeLine(diff.toString() + \", \" + leftWheelSpeed.toString() + \", \" + rightWheelSpeed.toString());"],[0,"\n\n  "]],"start1":630,"start2":630,"length1":92,"length2":305}]}]},{"timestamp":1738881031150,"editorVersion":"7.0.57","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"S = "],[-1,"30"],[1,"25"],[0,";\n\nlet "],[-1,"w"],[1,"leftW"],[0,"heel"],[-1,"L"],[0,"Spee"]],"start1":120,"start2":120,"length1":23,"length2":26},{"diffs":[[0," 0;\nlet "],[-1,"w"],[1,"rightW"],[0,"heel"],[-1,"R"],[0,"Speed = "]],"start1":149,"start2":149,"length1":22,"length2":26},{"diffs":[[0,"on.B)){\n        "],[-1,"w"],[1,"leftW"],[0,"heel"],[-1,"L"],[0,"Speed = 0.4;\n   "]],"start1":462,"start2":462,"length1":38,"length2":41},{"diffs":[[0,"elSpeed = 0."],[-1,"4"],[1,"1"],[0,";\n        wh"]],"start1":485,"start2":485,"length1":25,"length2":25},{"diffs":[[0," = 0.1;\n        "],[-1,"w"],[1,"rightW"],[0,"heel"],[-1,"R"],[0,"Speed = -0.4;\n  "]],"start1":492,"start2":492,"length1":38,"length2":42},{"diffs":[[0,"lSpeed = -0."],[-1,"4"],[1,"1"],[0,";\n    } else"]],"start1":517,"start2":517,"length1":25,"length2":25},{"diffs":[[0,"on.B)){\n        "],[-1,"w"],[1,"leftW"],[0,"heel"],[-1,"L"],[0,"Speed = -0.4;\n  "]],"start1":573,"start2":573,"length1":38,"length2":41},{"diffs":[[0,"ed = -0."],[-1,"4"],[1,"1"],[0,";\n      "]],"start1":601,"start2":601,"length1":17,"length2":17},{"diffs":[[0,"= -0.1;\n        "],[-1,"w"],[1,"rightW"],[0,"heel"],[-1,"R"],[0,"Speed = 0.4;\n   "]],"start1":604,"start2":604,"length1":38,"length2":42},{"diffs":[[0,"= 0."],[-1,"4"],[1,"1"],[0,";\n  "]],"start1":636,"start2":636,"length1":9,"length2":9},{"diffs":[[0,"    "],[-1,"wheelLSpeed = 0;\n        w"],[1,"leftW"],[0,"heel"],[-1,"R"],[0,"Spee"]],"start1":660,"start2":660,"length1":39,"length2":17},{"diffs":[[0,"    "],[-1,"}\n\n"],[0,"    "],[-1,"// Fix the weird thing with negative speeds\n    if (wheelLSpeed < 0){\n        w"],[1,"rightW"],[0,"heel"],[-1,"L"],[0,"Speed = "],[-1,"-1 - wheelLSpeed;\n    } if (wheelRSpeed < 0){\n        wheelRSpeed = -1 - wheelRSpeed;\n    }\n    motion.drive(wheelLSpeed * 100, wheelRSpeed * 100);"],[1,"0;\n    }\n\n    "],[0,"\n\n  "]],"start1":684,"start2":684,"length1":254,"length2":44},{"diffs":[[0,"(time - "],[-1,"temp"],[1,"last"],[0,"Time) * "]],"start1":833,"start2":833,"length1":20,"length2":20}]}]},{"timestamp":1738881706378,"editorVersion":"7.0.57","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"me\n\n"],[-1,"    \n\n"],[0,"    "]],"start1":381,"start2":381,"length1":14,"length2":8}]}]},{"timestamp":1738881711690,"editorVersion":"7.0.57","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[1,"// let brightness = 0;\n"],[0,"let lastTime"]],"start1":0,"start2":0,"length1":12,"length2":35},{"diffs":[[0,"S = "],[-1,"15"],[1,"30"],[0,";\n\nl"]],"start1":120,"start2":120,"length1":10,"length2":10},{"diffs":[[0,"ed = 0;\n"],[1,"\nlet heading = 0;\n\n"],[0,"// if go"]],"start1":163,"start2":163,"length1":16,"length2":35},{"diffs":[[0,"    "],[-1,"// XYZ\n    serial.writeLine(input.acceleration(Dimension.X).toString() + \", \" + input.acceleration(Dimension.Y).toString() + \", \" + input.acceleration(Dimension.Z).toString());"],[1,"\n\n    if (input.buttonIsPressed(Button.A) && !input.buttonIsPressed(Button.B)){\n        wheelLSpeed = 0.4;\n        wheelRSpeed = -0.4;\n    } else if (input.buttonIsPressed(Button.B)){\n        wheelLSpeed = -0.4;\n        wheelRSpeed = 0.4;\n    } else {\n        wheelLSpeed = 0;\n        wheelRSpeed = 0;\n    }"],[0,"\n\n  "]],"start1":385,"start2":385,"length1":184,"length2":315},{"diffs":[[0,"ed * 100);\n\n"],[1,"    let tempTime = lastTime;\n"],[0,"    lastTime"]],"start1":931,"start2":931,"length1":24,"length2":53},{"diffs":[[0,".max(0, "],[-1,"("],[0,"1000000 "]],"start1":1020,"start2":1020,"length1":17,"length2":16},{"diffs":[[0,"tFPS"],[-1,")"],[0," - ("],[-1,"1000000 * (input.runningTimeMicros() /"],[1,"time - tempTime) *"],[0," 1000000"],[-1," - time))));\n\n    if (input.buttonIsPressed(Button.B)) {\n        control.reset();\n    "],[1,"));\n"],[0,"}\n"],[-1,"}"],[0,"\n"]],"start1":1043,"start2":1043,"length1":145,"length2":41}]}]},{"timestamp":1738882301782,"editorVersion":"7.0.57","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"5;\n\n"],[-1,"let forwardHeading = 0;\n\nwhile (!input.buttonIsPressed(Button.B)){\n    serial.writeString(\".\");\n}\n\nmusic.setVolume(127);\n\n\n"],[0,"let "]],"start1":102,"start2":102,"length1":131,"length2":8},{"diffs":[[0,"ed = 0;\n"],[1,""],[0,"let whee"]],"start1":119,"start2":119,"length1":16,"length2":16},{"diffs":[[0," XYZ\n   "],[-1," //"],[0," serial."]],"start1":349,"start2":349,"length1":19,"length2":16},{"diffs":[[0,");\n\n"],[-1,"    serial.writeLine(input.compassHeading().toString());\n\n"],[0,"    "]],"start1":521,"start2":521,"length1":66,"length2":8},{"diffs":[[0,".max(0, "],[-1,"1"],[1,"(1000000"],[0," / targe"]],"start1":818,"start2":818,"length1":17,"length2":24},{"diffs":[[0,"argetFPS"],[1,")"],[0," -"],[1," (1000000 *"],[0," (input."]],"start1":838,"start2":838,"length1":18,"length2":30},{"diffs":[[0,"s() "],[-1,"- time)) * 1000000);"],[1,"/ 1000000 - time))));\n\n    if (input.buttonIsPressed(Button.B)) {\n        control.reset();\n    }"],[0,"\n}\n"]],"start1":884,"start2":884,"length1":27,"length2":103}]}]},{"timestamp":1738882887130,"editorVersion":"7.0.57","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"S = "],[-1,"30;"],[1,"15;\n\nlet forwardHeading = 0;\n\nwhile (!input.buttonIsPressed(Button.B)){\n    serial.writeString(\".\");\n}\n\nmusic.setVolume(127);\n"],[0,"\n\nle"]],"start1":97,"start2":97,"length1":11,"length2":134},{"diffs":[[0,"String());\n\n"],[1,"    serial.writeLine(input.compassHeading().toString());\n\n"],[0,"    // Fix t"]],"start1":639,"start2":639,"length1":24,"length2":82},{"diffs":[[0,"= time;\n"],[1,""],[0,"    cont"]],"start1":967,"start2":967,"length1":16,"length2":16},{"diffs":[[0,"Micros()"],[-1," / 1000000"],[0," - time)"]],"start1":1044,"start2":1044,"length1":26,"length2":16}]}]},{"timestamp":1738883461986,"editorVersion":"7.0.57","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0," 60;"],[-1,"\nlet deltaTime = 0;"],[0,"\n\nco"]],"start1":77,"start2":77,"length1":27,"length2":8},{"diffs":[[0,"S = "],[-1,"100"],[1,"3"],[0,"0;\n\nlet "],[-1,"l"],[1,"wheelL"],[0,"Spee"]],"start1":97,"start2":97,"length1":20,"length2":23},{"diffs":[[0," 0;\nlet "],[-1,"r"],[1,"wheelR"],[0,"Speed = "]],"start1":123,"start2":123,"length1":17,"length2":22},{"diffs":[[0,"20\n\n"],[-1,"let isCountdown = false;\nlet countdown = 0;\n\n"],[0,"whil"]],"start1":261,"start2":261,"length1":53,"length2":8},{"diffs":[[0,"time"],[-1,"\n    deltaTime = time - lastTime;"],[0,"\n\n  "]],"start1":337,"start2":337,"length1":41,"length2":8},{"diffs":[[0,");\n\n"],[-1,"    if (!isCountdown && input.buttonIsPressed(Button.B)){\n        isCountdown = true;\n        countdown = 2;\n    } else if (isCountdown){\n        countdown -= deltaTime;\n        if (countdown < 0){\n            isCountdown = false;\n            coun\n        }\n    }\n\n"],[0,"    "]],"start1":524,"start2":524,"length1":273,"length2":8},{"diffs":[[0,"    if ("],[-1,"l"],[1,"wheelL"],[0,"Speed < "]],"start1":576,"start2":576,"length1":17,"length2":22},{"diffs":[[0,"        "],[-1,"l"],[1,"wheelL"],[0,"Speed = "]],"start1":602,"start2":602,"length1":17,"length2":22},{"diffs":[[0," = -1 - "],[-1,"l"],[1,"wheelL"],[0,"Speed;\n "]],"start1":621,"start2":621,"length1":17,"length2":22},{"diffs":[[0,"  } if ("],[-1,"r"],[1,"wheelR"],[0,"Speed < "]],"start1":644,"start2":644,"length1":17,"length2":22},{"diffs":[[0,"        "],[-1,"r"],[1,"wheelR"],[0,"Speed = "]],"start1":670,"start2":670,"length1":17,"length2":22},{"diffs":[[0," = -1 - "],[-1,"r"],[1,"wheelR"],[0,"Speed;\n "]],"start1":689,"start2":689,"length1":17,"length2":22},{"diffs":[[0,"n.drive("],[-1,"l"],[1,"wheelL"],[0,"Speed * "]],"start1":725,"start2":725,"length1":17,"length2":22},{"diffs":[[0," * 100, "],[-1,"r"],[1,"wheelR"],[0,"Speed * "]],"start1":744,"start2":744,"length1":17,"length2":22},{"diffs":[[0,"ed * 100);\n\n"],[1,"    lastTime = time;\n"],[0,"    control."]],"start1":761,"start2":761,"length1":24,"length2":45},{"diffs":[[0,"00);"],[-1," // Just be around the fps target\n    lastTime = time;"],[0,"\n}\n"]],"start1":898,"start2":898,"length1":61,"length2":7}]}]},{"timestamp":1738884060753,"editorVersion":"7.0.57","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"e = 0;\n\n"],[-1,"// "],[0,"const ta"]],"start1":94,"start2":94,"length1":19,"length2":16},{"diffs":[[0,"= 1000;\n"],[1,""],[0,"\nlet lSp"]],"start1":118,"start2":118,"length1":16,"length2":16},{"diffs":[[0,"se;\n"],[-1,"let isRunning = false;\n"],[0,"let "]],"start1":297,"start2":297,"length1":31,"length2":8},{"diffs":[[0,");\n\n"],[-1,"    serial.writeLine(isRunning.toString() + \", \" + isCountdown.toString() + \", \" + countdown);\n\n    if (!isRunning){\n    "],[0,"    "]],"start1":613,"start2":613,"length1":129,"length2":8},{"diffs":[[0,"on.B)){\n"],[-1,"    "],[0,"        "]],"start1":667,"start2":667,"length1":20,"length2":16},{"diffs":[[0,"= true;\n        "],[-1,"    "],[0,"countdown = 2;\n "]],"start1":695,"start2":695,"length1":36,"length2":32},{"diffs":[[0," 2;\n    "],[-1,"   "],[-1," "],[0,"} else i"]],"start1":722,"start2":722,"length1":20,"length2":16},{"diffs":[[0,"n){\n"],[-1,"            countdown -= deltaTime;\n            if (countdown < 0){\n                isCountdown = false;\n\n                countdown = 0.5; // How long it will turn\n                \n                lSpeed = -0.5;\n                rSpeed = 0.5;\n                isRunning = true;\n            }\n        }\n    } else {\n        // is running\n"],[0,"    "]],"start1":751,"start2":751,"length1":343,"length2":8},{"diffs":[[0," deltaTime;\n"],[-1,"\n"],[0,"        if ("]],"start1":775,"start2":775,"length1":25,"length2":24},{"diffs":[[0,"    "],[-1,"lSpeed = 0;\n            rSpeed = 0;\n\n            isRunning = false;"],[1,"isCountdown = false;\n            coun"],[0,"\n   "]],"start1":823,"start2":823,"length1":75,"length2":45},{"diffs":[[0," 100);\n\n"],[1,""],[0,"   "],[-1," //"],[0," control"]],"start1":1079,"start2":1079,"length1":22,"length2":19}]}]},{"timestamp":1738884345025,"editorVersion":"7.0.57","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"me = 0;\n"],[1,"\n// "],[0,"const ta"]],"start1":93,"start2":93,"length1":16,"length2":20},{"diffs":[[0,"etFPS = "],[-1,"2"],[1,"100"],[0,"0;\n\nlet "]],"start1":115,"start2":115,"length1":17,"length2":19},{"diffs":[[0,"0;\n\n"],[-1,"let segment = 0;\n\nlet sonarDist = 0;\n\n"],[0,"whil"]],"start1":343,"start2":343,"length1":46,"length2":8},{"diffs":[[0,"e (true)"],[-1," "],[0,"{\n    ti"]],"start1":351,"start2":351,"length1":17,"length2":16},{"diffs":[[0,");\n\n"],[-1,"    sonarDist = sonar.checkSonar();\n    \n"],[0,"    "]],"start1":639,"start2":639,"length1":49,"length2":8},{"diffs":[[0,"ine("],[-1,"sonarDist"],[1,"isRunning"],[0,".toS"]],"start1":660,"start2":660,"length1":17,"length2":17},{"diffs":[[0,"ng()"],[-1,");\n\n    if (input.buttonIsPressed(Button.A)) {\n        isRunning = false;\n        isCountdown = false;\n        lSpeed = 0;\n        rSpeed = 0;\n    }"],[1," + \", \" + isCountdown.toString() + \", \" + countdown);"],[0,"\n\n  "]],"start1":680,"start2":680,"length1":156,"length2":61},{"diffs":[[0,"Running)"],[-1," "],[0,"{\n      "]],"start1":750,"start2":750,"length1":17,"length2":16},{"diffs":[[0,"tton.B))"],[-1," "],[0,"{\n      "]],"start1":812,"start2":812,"length1":17,"length2":16},{"diffs":[[0,"untdown)"],[-1," "],[0,"{\n      "]],"start1":904,"start2":904,"length1":17,"length2":16},{"diffs":[[0," (countdown < 0)"],[-1," "],[0,"{\n              "]],"start1":964,"start2":964,"length1":33,"length2":32},{"diffs":[[0,"own = 0."],[-1,"34"],[1,"5"],[0,"; // How"]],"start1":1042,"start2":1042,"length1":18,"length2":17},{"diffs":[[0,"ll turn\n"],[1,"                "],[0,"\n       "]],"start1":1070,"start2":1070,"length1":16,"length2":32},{"diffs":[[0,"    lSpeed = -0."],[-1,"3"],[1,"5"],[0,";\n              "]],"start1":1107,"start2":1107,"length1":33,"length2":33},{"diffs":[[0,"     rSpeed = 0."],[-1,"3"],[1,"5"],[0,";\n              "]],"start1":1137,"start2":1137,"length1":33,"length2":33},{"diffs":[[0,"e;\n\n"],[-1,"        if (segment % 2 == 0) {\n    "],[0,"    "]],"start1":1278,"start2":1278,"length1":44,"length2":8},{"diffs":[[0," (countdown < 0)"],[-1," "],[0,"{\n              "]],"start1":1292,"start2":1292,"length1":33,"length2":32},{"diffs":[[0,"    "],[-1,"    // will become odd, so is turn \n                segment++;\n\n                countdown = 0.34;\n\n                lSpeed = -0.3;\n                rSpeed = 0.3;\n            }\n        } else {\n            if (countdown < 0) {\n                // will be even, so is straights\n                segment++;\n\n                countdown = 2;\n\n                lSpeed = 0.65;\n                rSpeed = 0.65;\n            }\n        }\n\n        if (segment > 7) {\n            segment = 0"],[1,"lSpeed = 0;\n            rSpeed = 0;\n\n            isRunning = false"],[0,";\n  "]],"start1":1318,"start2":1318,"length1":478,"length2":74},{"diffs":[[0," if (lSpeed < 0)"],[-1," "],[0,"{\n        lSpeed"]],"start1":1458,"start2":1458,"length1":33,"length2":32},{"diffs":[[0,"eed < 0)"],[-1," "],[0,"{\n      "]],"start1":1519,"start2":1519,"length1":17,"length2":16},{"diffs":[[0,"  //"],[-1," no work:\n   "],[0," con"]],"start1":1614,"start2":1614,"length1":21,"length2":8},{"diffs":[[0,"ath."],[-1,"round(Math."],[0,"max("]],"start1":1639,"start2":1639,"length1":19,"length2":8},{"diffs":[[0,"1000000)"],[-1,")"],[0,"; // Jus"]],"start1":1714,"start2":1714,"length1":17,"length2":16}]}]},{"timestamp":1738967032862,"editorVersion":"7.0.57","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"ork:\n   "],[-1," //"],[0," control"]],"start1":2224,"start2":2224,"length1":19,"length2":16}]}]},{"timestamp":1738967318964,"editorVersion":"7.0.57","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"hile"],[1," "],[0,"(true)"],[1," "],[0,"{\n  "]],"start1":380,"start2":380,"length1":14,"length2":16},{"diffs":[[0,"    "],[-1,"sonarDist = sonarDist == 0 ? 150 : sonarDist;\n    \n    serial.writeLine(Math.roundWithPrecision(sonarDist, 2).toString() + \", \" + Math.roundWithPrecision(1 / deltaTime, 2).toString());\n\n    if (input.buttonIsPressed(Button.A)) {\n        isRunning = false;\n        isCountdown = false;\n        lSpeed = 0;\n        rSpeed = 0;\n    }\n\n    square(); // Run turning code stuff\n\n    // Fix the weird thing with negative speeds\n    if (lSpeed < 0) {\n        lSpeed = -1 - lSpeed;\n    } if (rSpeed < 0) {\n        rSpeed = -1 - rSpeed;\n    }\n    motion.drive(lSpeed * 100, rSpeed * 100);\n\n    // no work:\n    // control.waitMicros(Math.round(Math.max(0, 1 / targetFPS - (input.runningTimeMicros() / 1000000 - time)) * 1000000)); // Just be around the fps target\n    lastTime = time;\n}\n\nfunction square(){"],[1,"\n    serial.writeLine(sonarDist.toString());\n\n    if (input.buttonIsPressed(Button.A)) {\n        isRunning = false;\n        isCountdown = false;\n        lSpeed = 0;\n        rSpeed = 0;\n    }\n"],[0,"\n   "]],"start1":712,"start2":712,"length1":803,"length2":199},{"diffs":[[0,"}\n    }\n"],[-1,"}"],[1,"\n    // Fix the weird thing with negative speeds\n    if (lSpeed < 0) {\n        lSpeed = -1 - lSpeed;\n    } if (rSpeed < 0) {\n        rSpeed = -1 - rSpeed;\n    }\n    motion.drive(lSpeed * 100, rSpeed * 100);\n\n    // no work:\n    // control.waitMicros(Math.round(Math.max(0, 1 / targetFPS - (input.runningTimeMicros() / 1000000 - time)) * 1000000)); // Just be around the fps target\n    lastTime = time;\n}\n"]],"start1":1997,"start2":1997,"length1":9,"length2":412}]}]},{"timestamp":1738967971685,"editorVersion":"7.0.57","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"  }\n\n   "],[-1," //"],[0," square("]],"start1":1041,"start2":1041,"length1":19,"length2":16}]}]},{"timestamp":1738967985432,"editorVersion":"7.0.57","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"is -20\n\n"],[-1,"// "],[0,"let isCo"]],"start1":265,"start2":265,"length1":19,"length2":16},{"diffs":[[0,"se;\n"],[-1,"let isTurning = false;\nlet counter = 0;\nlet turningSegment = 0;\n// "],[0,"let "]],"start1":317,"start2":317,"length1":75,"length2":8},{"diffs":[[0,"n = 0;\n\n"],[-1,"// "],[0,"let segm"]],"start1":333,"start2":333,"length1":19,"length2":16},{"diffs":[[0,"\n       "],[-1," //"],[0," isCount"]],"start1":969,"start2":969,"length1":19,"length2":16},{"diffs":[[0," }\n\n"],[-1,"    if (input.buttonIsPressed(Button.B)) {\n        isRunning = true;\n        lSpeed = 0.65;\n        rSpeed = 0.65;\n    }\n\n    if (isRunning){\n        // If it is < 45cm away for 4 ticks in a row, than turning\n        if (!isTurning){\n            if (sonarDist < 45){\n                counter++;\n                if (counter > 4){\n                    isTurning = true;\n                    turningSegment = 0;\n\n                    counter = 0;\n                }\n            } else {\n                counter = 0;\n            }\n        }\n\n        // turning parts\n        if (isTurning){\n            switch (turningSegment){\n                case 0:\n                    \n                    break;\n                case 1:\n\n                    break;\n                case 2:\n\n                    break;\n                case 3:\n\n                    break;\n            }\n        }\n    }\n\n"],[0,"    "]],"start1":1042,"start2":1042,"length1":886,"length2":8},{"diffs":[[0,"ime;\n}\n\n"],[-1,"// "],[0,"function"]],"start1":1486,"start2":1486,"length1":19,"length2":16},{"diffs":[[0,"uare(){\n"],[-1,"// "],[0,"    if ("]],"start1":1505,"start2":1505,"length1":19,"length2":16},{"diffs":[[0,"sRunning) {\n"],[-1,"// "],[0,"        if ("]],"start1":1523,"start2":1523,"length1":27,"length2":24},{"diffs":[[0,"utton.B)) {\n"],[-1,"// "],[0,"            "]],"start1":1586,"start2":1586,"length1":27,"length2":24},{"diffs":[[0,"untdown = true;\n"],[-1,"//"],[0,"             cou"]],"start1":1614,"start2":1614,"length1":34,"length2":32},{"diffs":[[0,"ue;\n            "],[-1," "],[0,"countdown = 2;\n/"]],"start1":1626,"start2":1626,"length1":33,"length2":32},{"diffs":[[0,"wn = 2;\n"],[-1,"// "],[0,"        "]],"start1":1649,"start2":1649,"length1":19,"length2":16},{"diffs":[[0,"ountdown) {\n"],[-1,"// "],[0,"            "]],"start1":1679,"start2":1679,"length1":27,"length2":24},{"diffs":[[0,"taTime;\n"],[-1,"// "],[0,"        "]],"start1":1719,"start2":1719,"length1":19,"length2":16},{"diffs":[[0,"ountdown < 0) {\n"],[-1,"// "],[0,"                "]],"start1":1744,"start2":1744,"length1":35,"length2":32},{"diffs":[[0,"n = false;\n\n"],[-1,"// "],[0,"            "]],"start1":1786,"start2":1786,"length1":27,"length2":24},{"diffs":[[0,"l turn\n\n"],[-1,"// "],[0,"        "]],"start1":1850,"start2":1850,"length1":19,"length2":16},{"diffs":[[0," lSpeed = -0.3;\n"],[-1,"//"],[0,"                "]],"start1":1873,"start2":1873,"length1":34,"length2":32},{"diffs":[[0,"                "],[-1," "],[0,"rSpeed = 0.3;\n//"]],"start1":1889,"start2":1889,"length1":33,"length2":32},{"diffs":[[0,"  rSpeed = 0.3;\n"],[-1,"// "],[0,"                "]],"start1":1903,"start2":1903,"length1":35,"length2":32},{"diffs":[[0,"= true;\n"],[-1,"// "],[0,"        "]],"start1":1945,"start2":1945,"length1":19,"length2":16},{"diffs":[[0,";\n            }\n"],[-1,"// "],[0,"        }\n//    "]],"start1":1951,"start2":1951,"length1":35,"length2":32},{"diffs":[[0,"      }\n"],[-1,"//"],[0,"    "],[-1," "],[0,"} else {"]],"start1":1969,"start2":1969,"length1":23,"length2":20},{"diffs":[[0," }\n    } else {\n"],[-1,"// "],[0,"        // is ru"]],"start1":1974,"start2":1974,"length1":35,"length2":32},{"diffs":[[0,"running\n"],[-1,"// "],[0,"        "]],"start1":2004,"start2":2004,"length1":19,"length2":16},{"diffs":[[0,"aTime;\n\n"],[-1,"// "],[0,"        "]],"start1":2037,"start2":2037,"length1":19,"length2":16},{"diffs":[[0,"% 2 == 0) {\n"],[-1,"// "],[0,"            "]],"start1":2065,"start2":2065,"length1":27,"length2":24},{"diffs":[[0,"ountdown < 0) {\n"],[-1,"// "],[0,"                "]],"start1":2094,"start2":2094,"length1":35,"length2":32},{"diffs":[[0,"s turn \n"],[-1,"// "],[0,"        "]],"start1":2150,"start2":2150,"length1":19,"length2":16},{"diffs":[[0,"    segment++;\n\n"],[-1,"// "],[0,"                "]],"start1":2170,"start2":2170,"length1":35,"length2":32},{"diffs":[[0," 0.34;\n\n"],[-1,"// "],[0,"        "]],"start1":2213,"start2":2213,"length1":19,"length2":16},{"diffs":[[0,"eed = -0.3;\n"],[-1,"//"],[0,"            "]],"start1":2240,"start2":2240,"length1":26,"length2":24},{"diffs":[[0,"                "],[-1," "],[0,"rSpeed = 0.3;\n//"]],"start1":2252,"start2":2252,"length1":33,"length2":32},{"diffs":[[0," = 0.3;\n"],[-1,"// "],[0,"        "]],"start1":2274,"start2":2274,"length1":19,"length2":16},{"diffs":[[0,";\n            }\n"],[-1,"// "],[0,"        } else {"]],"start1":2280,"start2":2280,"length1":35,"length2":32},{"diffs":[[0," else {\n"],[-1,"// "],[0,"        "]],"start1":2305,"start2":2305,"length1":19,"length2":16},{"diffs":[[0,"down < 0) {\n"],[-1,"// "],[0,"            "]],"start1":2334,"start2":2334,"length1":27,"length2":24},{"diffs":[[0,"raights\n"],[-1,"//"],[0,"        "]],"start1":2387,"start2":2387,"length1":18,"length2":16},{"diffs":[[0,"                "],[-1," "],[0,"segment++;\n\n//  "]],"start1":2395,"start2":2395,"length1":33,"length2":32},{"diffs":[[0,"ent++;\n\n"],[-1,"// "],[0,"        "]],"start1":2415,"start2":2415,"length1":19,"length2":16},{"diffs":[[0,"n = 2;\n\n"],[-1,"// "],[0,"        "]],"start1":2447,"start2":2447,"length1":19,"length2":16},{"diffs":[[0," lSpeed = 0.65;\n"],[-1,"// "],[0,"                "]],"start1":2470,"start2":2470,"length1":35,"length2":32},{"diffs":[[0,"= 0.65;\n"],[-1,"// "],[0,"        "]],"start1":2509,"start2":2509,"length1":19,"length2":16},{"diffs":[[0,"          }\n"],[-1,"// "],[0,"        }\n\n/"]],"start1":2519,"start2":2519,"length1":27,"length2":24},{"diffs":[[0,"     }\n\n"],[-1,"// "],[0,"        "]],"start1":2534,"start2":2534,"length1":19,"length2":16},{"diffs":[[0," > 7) {\n"],[-1,"// "],[0,"        "]],"start1":2561,"start2":2561,"length1":19,"length2":16},{"diffs":[[0," 0;\n"],[-1,"//"],[0,"        "],[-1," "],[0,"}\n"],[-1,"// "],[0,"    }\n"],[-1,"// "],[0,"}"]],"start1":2590,"start2":2590,"length1":30,"length2":21}]}]},{"timestamp":1738968622233,"editorVersion":"7.0.57","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0," case 0:"],[-1," // "],[0,"\n       "]],"start1":1756,"start2":1756,"length1":20,"length2":16}]}]},{"timestamp":1738968673342,"editorVersion":"7.0.57","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"se;\nlet "],[-1,"sonarC"],[1,"c"],[0,"ounter ="]],"start1":343,"start2":343,"length1":22,"length2":17},{"diffs":[[0," 0;\n"],[-1,"let timeCounter = 0;\n// "],[0,"let "]],"start1":360,"start2":360,"length1":32,"length2":8},{"diffs":[[0," XYZ\n   "],[1," //"],[0," serial."]],"start1":568,"start2":568,"length1":16,"length2":19},{"diffs":[[0,"narDist;"],[1,"\n    \n    serial.writeLine(Math.roundWithPrecision(sonarDist, 2).toString() + \", \" + Math.roundWithPrecision(1 / deltaTime, 2).toString());"],[0,"\n\n    if"]],"start1":824,"start2":824,"length1":16,"length2":155},{"diffs":[[0,"                "],[-1,"sonarC"],[1,"c"],[0,"ounter++;\n      "]],"start1":1389,"start2":1389,"length1":38,"length2":33},{"diffs":[[0,"            if ("],[-1,"sonarC"],[1,"c"],[0,"ounter > 3){\n   "]],"start1":1420,"start2":1420,"length1":38,"length2":33},{"diffs":[[0,"  if (counter > "],[-1,"3"],[1,"4"],[0,"){\n             "]],"start1":1430,"start2":1430,"length1":33,"length2":33},{"diffs":[[0,"            "],[-1," //"],[0," turningSegm"]],"start1":1495,"start2":1495,"length1":27,"length2":24},{"diffs":[[0,"    "],[-1,"     "],[-1,"lSpeed = -0.3;\n                    rSpeed = 0.3;\n\n                    sonarC"],[1,"     c"],[0,"ount"]],"start1":1540,"start2":1540,"length1":89,"length2":14},{"diffs":[[0,"                "],[-1,"sonarC"],[1,"c"],[0,"ounter = 0;\n    "]],"start1":1601,"start2":1601,"length1":38,"length2":33},{"diffs":[[0,"      }\n"],[-1,"\n\n"],[0,"        "]],"start1":1636,"start2":1636,"length1":18,"length2":16},{"diffs":[[0,"        "],[-1," //"],[0," switch "]],"start1":1707,"start2":1707,"length1":19,"length2":16},{"diffs":[[0,"nt){\n           "],[-1," //"],[0,"     case 0:\n   "]],"start1":1736,"start2":1736,"length1":35,"length2":32},{"diffs":[[0," case 0:"],[1," // "],[0,"\n       "]],"start1":1756,"start2":1756,"length1":16,"length2":20},{"diffs":[[0,"    \n           "],[-1," //"],[0,"         break;\n"]],"start1":1785,"start2":1785,"length1":35,"length2":32},{"diffs":[[0,"            "],[-1,"//"],[0,"    "],[-1," "],[0,"case 1:\n\n   "]],"start1":1817,"start2":1817,"length1":31,"length2":28},{"diffs":[[0," 1:\n\n           "],[-1," //"],[0,"         break;\n"]],"start1":1837,"start2":1837,"length1":35,"length2":32},{"diffs":[[0,"eak;\n           "],[-1," //"],[0,"     case 2:\n\n  "]],"start1":1864,"start2":1864,"length1":35,"length2":32},{"diffs":[[0," 2:\n\n           "],[-1," //"],[0,"         break;\n"]],"start1":1889,"start2":1889,"length1":35,"length2":32},{"diffs":[[0,"\n           "],[-1," //"],[0,"     case 3:"]],"start1":1920,"start2":1920,"length1":27,"length2":24},{"diffs":[[0,"    "],[-1,"//"],[0,"        "],[-1," "],[0,"break;\n"],[-1,"            // }\n            if (sonarDist > 45){\n                sonarCounter++;\n            }\n\n            if (sonarCounter > 3){\n                isTurning = false;\n                sonarCounter = 0;\n                \n                lSpeed = 0.65;\n                rSpeed = 0.65;\n"],[0,"    "]],"start1":1954,"start2":1954,"length1":306,"length2":23}]}]},{"timestamp":1738969270716,"editorVersion":"7.0.57","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"let "],[-1,"accelerometer"],[1,"time"],[0,"Coun"]],"start1":369,"start2":369,"length1":21,"length2":12},{"diffs":[[0,"gment = 0;\n\n"],[1,""],[0,"let sonarDis"]],"start1":449,"start2":449,"length1":24,"length2":24},{"diffs":[[0,"0;\n\n"],[-1,"let dot = (a: Array<Number>, b: Array<Number>) => a.map((x: Number, i: Number) => a[i] * b[i]).reduce((m, n) => m + n);\n\n"],[0,"whil"]],"start1":477,"start2":477,"length1":129,"length2":8},{"diffs":[[0,");\n\n"],[-1,"    let upVector = Math.\n\n"],[0,"    "]],"start1":769,"start2":769,"length1":34,"length2":8}]}]},{"timestamp":1738969865980,"editorVersion":"7.0.57","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"0;\n\n"],[-1,"function dotProduct(vector1"],[1,"let dot = (a"],[0,": Array<"],[-1,"n"],[1,"N"],[0,"umber>, "],[-1,"vector2"],[1,"b"],[0,": Array<"],[-1,"n"],[1,"N"],[0,"umber>) "],[-1,"{\n    let result = 0;\n    for (let i = 0; i < vector1.length; i++) {\n        result += vector1[i] * vector2[i];\n    }\n    return result;\n}"],[1,"=> a.map((x: Number, i: Number) => a[i] * b[i]).reduce((m, n) => m + n);"],[0,"\n\nwh"]],"start1":486,"start2":486,"length1":214,"length2":127},{"diffs":[[0,"    "],[-1,"let xA = "],[1,"serial.writeLine("],[0,"inpu"]],"start1":732,"start2":732,"length1":17,"length2":25},{"diffs":[[0,"n.X)"],[-1,";\n    let yA ="],[1,".toString() + \", \" +"],[0," inp"]],"start1":780,"start2":780,"length1":22,"length2":28},{"diffs":[[0,"n.Y)"],[-1,";\n    let zA ="],[1,".toString() + \", \" +"],[0," inp"]],"start1":832,"start2":832,"length1":22,"length2":28},{"diffs":[[0,"n.Z)"],[-1,";\n\n    let upVector = dotProduct([Math.cos(135 / 180 * Math.PI) * zA, Math.sin(135 / 180 * Math.PI) * zA], [Math.cos(135 / 180 * Math.PI) * -yA, Math.sin(135 / 180 * Math.PI) * -yA])\n    serial.writeLine(xA.toString() + \", \" + yA.toString() + \", \" + zA.toString() + \", \" + upVector.toString());"],[1,".toString());\n\n    let upVector = Math."],[0,"\n\n  "]],"start1":884,"start2":884,"length1":302,"length2":47}]}]},{"timestamp":1738970289036,"editorVersion":"7.0.57","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"t = 0;\n\n"],[1,"function dotProduct(vector1: Array<number>, vector2: Array<number>) {\n    let result = 0;\n    for (let i = 0; i < vector1.length; i++) {\n        result += vector1[i] * vector2[i];\n    }\n    return result;\n}\n\n"],[0,"while(tr"]],"start1":482,"start2":482,"length1":16,"length2":224},{"diffs":[[0,"r = "],[-1,"Math.sin(-135/180*Math.PI) * (-yA + zA); // Get the vertical yeah\n    // let movementAngle = Math.atan2(upVector)\n"],[1,"dotProduct([Math.cos(135 / 180 * Math.PI) * zA, Math.sin(135 / 180 * Math.PI) * zA], [Math.cos(135 / 180 * Math.PI) * -yA, Math.sin(135 / 180 * Math.PI) * -yA])"],[0,"\n   "]],"start1":973,"start2":973,"length1":122,"length2":168}]}]},{"timestamp":1738970871677,"editorVersion":"7.0.57","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"me = 0;\n"],[-1,"// "],[0,"const ta"]],"start1":93,"start2":93,"length1":19,"length2":16},{"diffs":[[0,"tFPS = 2"],[-1,"5"],[1,"0"],[0,";\n\nlet l"]],"start1":112,"start2":112,"length1":17,"length2":17},{"diffs":[[0,"ath.sin("],[1,"-"],[0,"135/180*"]],"start1":770,"start2":770,"length1":16,"length2":17},{"diffs":[[0,"cal "],[-1,"mhmm\n    let forwardVector = Math.sin(-135/180*Math.PI) * (-yA + -zA);"],[1,"yeah"],[0,"\n   "]],"start1":826,"start2":826,"length1":78,"length2":12},{"diffs":[[0,"\" + "],[-1,"Math.round(upVector).toString() + \", \" + Math.round(forwardVector)"],[1,"upVector"],[0,".toS"]],"start1":970,"start2":970,"length1":74,"length2":16}]}]},{"timestamp":1738971416461,"editorVersion":"7.0.57","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"me = 0;\n"],[1,"// "],[0,"const ta"]],"start1":93,"start2":93,"length1":16,"length2":19},{"diffs":[[0,"ctor = Math.sin("],[1,"-"],[0,"135/180*Math.PI)"]],"start1":854,"start2":854,"length1":32,"length2":33},{"diffs":[[0,"zA);"],[-1," // Positive = acceleration forward"],[0,"\n   "]],"start1":898,"start2":898,"length1":43,"length2":8},{"diffs":[[0,"iteLine("],[1,"xA.toString() + \", \" + yA.toString() + \", \" + zA.toString() + \", \" + "],[0,"Math.rou"]],"start1":965,"start2":965,"length1":16,"length2":85},{"diffs":[[0," }\n\n"],[-1,"            if ()"],[0,"\n   "]],"start1":1971,"start2":1971,"length1":25,"length2":8},{"diffs":[[0,"ath."],[-1,"max(0, Math.round("],[1,"round(Math.max(0, "],[0,"1 / "]],"start1":2933,"start2":2933,"length1":26,"length2":26}]}]},{"timestamp":1738971949476,"editorVersion":"7.0.57","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"if ("],[-1,"forwardVector < -500){\n                isTurning = true;\n                lSpeed = -0.4;\n                rSpeed = -0.2;\n            }"],[1,")"],[0,"\n   "]],"start1":1949,"start2":1949,"length1":140,"length2":9}]}]},{"timestamp":1738972353144,"editorVersion":"7.0.57","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"t = 0;\n\n"],[-1,"\n"],[0,"while(tr"]],"start1":482,"start2":482,"length1":17,"length2":16}]}]},{"timestamp":1739041287705,"editorVersion":"7.0.57","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0," 0;\n"],[-1,"let upVector = 0;"],[0,"\n\nwh"]],"start1":485,"start2":485,"length1":25,"length2":8}]}]},{"timestamp":1739041290281,"editorVersion":"7.0.57","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"= 0;"],[-1,"\nlet forwardVector = 0;"],[0,"\n\nwh"]],"start1":502,"start2":502,"length1":31,"length2":8},{"diffs":[[0,"    "],[-1,"calculateAcceleration();\n    sonarDist = sonar.checkSonar();\n    sonarDist = sonarDist == 0 ? 150 : sonarDist;"],[1,"let xA = input.acceleration(Dimension.X);\n    let yA = input.acceleration(Dimension.Y);\n    let zA = input.acceleration(Dimension.Z);\n\n    let upVector = Math.sin(135/180*Math.PI) * (-yA + zA); // Get the vertical mhmm\n    let forwardVector = Math.sin(135/180*Math.PI) * (-yA + -zA); // Positive = acceleration forward\n    // let movementAngle = Math.atan2(upVector)"],[0,"\n\n  "]],"start1":629,"start2":629,"length1":118,"length2":374},{"diffs":[[0,"String());\n\n"],[1,"    sonarDist = sonar.checkSonar();\n    sonarDist = sonarDist == 0 ? 150 : sonarDist;\n\n"],[0,"    if (inpu"]],"start1":1091,"start2":1091,"length1":24,"length2":111},{"diffs":[[0,".65;\n    }\n\n"],[1,"    if (isRunning){\n        // If it is < 45cm away for 4 ticks in a row, than turning\n        if (!isTurning){\n            if (sonarDist < 45){\n                sonarCounter++;\n                if (sonarCounter > 3){\n                    isTurning = true;\n                    // turningSegment = 0;\n\n                    lSpeed = -0.3;\n                    rSpeed = 0.3;\n\n                    sonarCounter = 0;\n                }\n            } else {\n                sonarCounter = 0;\n            }\n\n            if (forwardVector < -500){\n                isTurning = true;\n                lSpeed = -0.4;\n                rSpeed = -0.2;\n            }\n        }\n\n        // turning parts\n        if (isTurning){\n            // switch (turningSegment){\n            //     case 0:\n                    \n            //         break;\n            //     case 1:\n\n            //         break;\n            //     case 2:\n\n            //         break;\n            //     case 3:\n\n            //         break;\n            // }\n            if (sonarDist > 45){\n                sonarCounter++;\n            }\n\n            if (sonarCounter > 3){\n                isTurning = false;\n                sonarCounter = 0;\n                \n                lSpeed = 0.65;\n                rSpeed = 0.65;\n            }\n        }\n    }\n\n    // square(); // Run turning code stuff\n\n"],[0,"    // Fix t"]],"start1":1449,"start2":1449,"length1":24,"length2":1374},{"diffs":[[0,"ime;\n}\n\n"],[1,"// "],[0,"function"]],"start1":3207,"start2":3207,"length1":16,"length2":19},{"diffs":[[0,"ion "],[-1,"calculateAcceleration(){\n    let xA = input.acceleration(Dimension.X);\n    let yA = input.acceleration(Dimension.Y);\n    let zA = input.acceleration(Dimension.Z);\n\n    upVector = Math.sin(135 / 180 * Math.PI) * (-yA + zA) + 1024; // Get the vertical velocity (accounting for gravity)\n    forwardVector = Math.sin(135 / 180 * Math.PI) * (-yA + -zA); // Positive = acceleration forward\n    // let movementAngle = Math.atan2(upVector)\n"],[1,"square(){\n//     if (!isRunning) {\n//         if (!isCountdown && input.buttonIsPressed(Button.B)) {\n//             isCountdown = true;\n//             countdown = 2;\n//         } else if (isCountdown) {\n//             countdown -= deltaTime;\n//             if (countdown < 0) {\n//                 isCountdown = false;\n\n//                 countdown = 0.34; // How long it will turn\n\n//                 lSpeed = -0.3;\n//                 rSpeed = 0.3;\n//                 isRunning = true;\n//             }\n//         }\n//     } else {\n//         // is running\n//         countdown -= deltaTime;\n\n//         if (segment % 2 == 0) {\n//             if (countdown < 0) {\n//                 // will become odd, so is turn \n//                 segment++;\n\n//                 countdown = 0.34;\n\n//                 lSpeed = -0.3;\n//                 rSpeed = 0.3;\n//             }\n//         } else {\n//             if (countdown < 0) {\n//                 // will be even, so is straights\n//                 segment++;\n\n//                 countdown = 2;\n\n//                 lSpeed = 0.65;\n//                 rSpeed = 0.65;\n//             }\n//         }\n\n//         if (segment > 7) {\n//             segment = 0;\n//         }\n//     }\n// "],[0,"}"]],"start1":3223,"start2":3223,"length1":437,"length2":1229}]}]},{"timestamp":1739041812176,"editorVersion":"7.0.57","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"is -20\n\n"],[1,"// let isCountdown = false;\nlet isRunning = false;\nlet isTurning = false;\nlet sonarCounter = 0;\nlet accelerometerCounter = 0;\n// let turningSegment = 0;\n// let countdown = 0;\n\n// let segment = 0;\n\n"],[0,"let sona"]],"start1":265,"start2":265,"length1":16,"length2":213},{"diffs":[[0,"utton.A)) {\n"],[1,"        isRunning = false;\n        // isCountdown = false;\n"],[0,"        lSpe"]],"start1":901,"start2":901,"length1":24,"length2":83},{"diffs":[[0,"utton.B)) {\n"],[1,"        isRunning = true;\n"],[0,"        lSpe"]],"start1":1050,"start2":1050,"length1":24,"length2":50},{"diffs":[[0,"eds\n    "],[-1,"driveMotors("],[1,"if (lSpeed < 0) {\n        lSpeed = -1 - lSpeed;\n    } if (rSpeed < 0) {\n        rSpeed = -1 - rSpeed;\n    }\n    motion.drive(lSpeed * 100, rSpeed * 100"],[0,");\n\n    "]],"start1":1185,"start2":1185,"length1":28,"length2":167},{"diffs":[[0,"forward\n"],[1,""],[0,"    // l"]],"start1":1930,"start2":1930,"length1":16,"length2":16},{"diffs":[[0,"r)\n}"],[-1,"\n\nfunction driveMotors(){\n    // Calculate \n    if (lSpeed < 0) {\n        lSpeed = -1 - lSpeed;\n    } if (rSpeed < 0) {\n        rSpeed = -1 - rSpeed;\n    }\n\n    motion.drive(lSpeed * 100, rSpeed * 100);\n}"]],"start1":1983,"start2":1983,"length1":208,"length2":4}]}]},{"timestamp":1739041957261,"editorVersion":"7.0.57","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0," // "],[-1,"inputs and measurements"],[1,"XYZ"],[0,"\n   "]],"start1":447,"start2":447,"length1":31,"length2":11},{"diffs":[[0,"    "],[-1,"driveMotors();\n\n    // Update for delta time calcualtions"],[1,"// Fix the weird thing with negative speeds\n    driveMotors();\n\n    // no work:\n    // control.waitMicros(Math.max(0, Math.round(1 / targetFPS - (input.runningTimeMicros() / 1000000 - time)) * 1000000)); // Just be around the fps target"],[0,"\n   "]],"start1":859,"start2":859,"length1":65,"length2":244},{"diffs":[[0,"ate "],[-1,"the input for the drive function, and drive"],[0,"\n   "]],"start1":1605,"start2":1605,"length1":51,"length2":8}]}]},{"timestamp":1739042547535,"editorVersion":"7.0.57","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"0;\n\n"],[-1,"let isCalibrating = true;\nlet calibrationCountdown = 3;\nwhile (isCalibrating){\n    if (input.buttonIsPressed(Button.A)){\n        \n    }\n}\n\nwhile "],[1,"while"],[0,"(tru"]],"start1":330,"start2":330,"length1":153,"length2":13},{"diffs":[[0,"(Button."],[-1,"B"],[1,"A"],[0,")) {\n   "]],"start1":722,"start2":722,"length1":17,"length2":17},{"diffs":[[0,"sPressed(Button."],[-1,"A"],[1,"B"],[0,")) {\n        lSp"]],"start1":804,"start2":804,"length1":33,"length2":33}]}]},{"timestamp":1739043002380,"editorVersion":"7.0.57","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"let "],[-1,"segment = 0; // 0 = calibration, 1 = button drive\nlet calibrationCountdown = 3;\n\nwhile (true){\n    time = input.runningTimeMicros() / 1000000; // Update time\n    deltaTime = time - lastTime;\n\n    if (segment == 0){\n        if (input.buttonIsPressed(Button.A) && calibrationCountdown == 3) {\n            calibrationCountdown -= deltaTime;\n        } else if (calibrationCountdown != 3){\n            calibrationCountdown -= deltaTime;\n\n            if (calibrationCountdown <= 0){\n                // Calibration!\n            }\n        }\n    }"],[1,"isCalibrating = true;\nlet calibrationCountdown = 3;\nwhile (isCalibrating){\n    if (input.buttonIsPressed(Button.A)){\n        \n    }\n}\n\nwhile (true){\n    time = input.runningTimeMicros() / 1000000; // Update time\n    deltaTime = time - lastTime;\n\n    // inputs and measurements\n    calculateAcceleration();\n    sonarDist = sonar.checkSonar();\n    sonarDist = sonarDist == 0 ? 150 : sonarDist;"],[0,"\n\n  "]],"start1":334,"start2":334,"length1":546,"length2":399}]}]},{"timestamp":1739043601246,"editorVersion":"7.0.57","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0," 3;\n"],[-1,"let calibrationLoops = 0;\nlet avgForwardVector = 0;\nlet avgUpVector = 0;\nlet forwardVectorOffset = 0;\nlet upVectorOffset = 0;\n\nwhile (true){\n    // Update time"],[1,"\nwhile (true){"],[0,"\n   "]],"start1":414,"start2":414,"length1":167,"length2":22},{"diffs":[[0,"000;"],[-1,"\n    deltaTime = time - lastT"],[1," // Update t"],[0,"ime"],[-1,";\n"],[0,"\n    "],[-1,"// Inputs and measurements\n    calculateAcceleration();\n    sonarDist = sonar.checkSonar();\n    sonarDist = sonarDist == 0 ? 150 : sonarDist"],[1,"deltaTime = time - lastTime"],[0,";\n\n "]],"start1":476,"start2":476,"length1":187,"length2":55},{"diffs":[[0,"    "],[-1,"    avgForwardVector += forwardVector;\n                avgUpVector += upVector;\n\n                calibrationLoops++;\n\n                if (calibrationLoops > 20){\n                    segment++; // Stops calibrating and moves on\n                    \n                    avgForwardVector /= calibrationLoops;\n                    avgUpVector /= calibrationLoops;\n                    \n                    forwardVectorOffset = -avgForwardVector;\n                    upVectorOffset = -avgUpVector;\n                }\n            }\n        }\n    } else if (segment == 1){\n"],[1,"}\n        }"],[0,"\n   "]],"start1":855,"start2":855,"length1":572,"length2":19},{"diffs":[[0,"1024"],[-1," + upVectorOffset"],[0,"; //"]],"start1":1485,"start2":1485,"length1":25,"length2":8},{"diffs":[[0,"-zA)"],[-1," + forwardVectorOffset"],[0,"; //"]],"start1":1604,"start2":1604,"length1":30,"length2":8}]}]},{"timestamp":1739044129866,"editorVersion":"7.0.57","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"Loops > "],[-1,"10"],[1,"2"],[0,"0){\n    "]],"start1":1285,"start2":1285,"length1":18,"length2":17},{"diffs":[[0," == 1){\n"],[1,"\n"],[0,"    "],[1,"}\n\n    serial.writeLine(Math.round(upVector).toString() + \", \" + Math.round(forwardVector).toString());\n\n"],[0,"    if ("]],"start1":1692,"start2":1692,"length1":20,"length2":126},{"diffs":[[0,"(Button."],[-1,"A"],[1,"B"],[0,")) {\n   "]],"start1":1839,"start2":1839,"length1":17,"length2":17},{"diffs":[[0,"    "],[-1,"    "],[0,"lSpeed "],[-1,"+"],[0,"= "],[-1,"deltaTime * 0.1;\n    "],[1,"0;\n"],[0,"    "]],"start1":1857,"start2":1857,"length1":43,"length2":20},{"diffs":[[0,"   rSpeed = "],[-1,"lSpeed"],[1,"0"],[0,";\n"],[-1,"    "],[0,"    }\n\n     "]],"start1":1878,"start2":1878,"length1":36,"length2":27},{"diffs":[[0,"\n    }\n\n    "],[-1,"  "],[-1,"  "],[0,"if (input.bu"]],"start1":1892,"start2":1892,"length1":28,"length2":24},{"diffs":[[0,"sPressed(Button."],[-1,"B"],[1,"A"],[0,")) {\n           "]],"start1":1921,"start2":1921,"length1":33,"length2":33},{"diffs":[[0,"    "],[-1,"   "],[-1," "],[0,"lSpeed "],[-1,"-"],[0,"= "],[-1,"deltaTime * 0.1"],[1,"0.65"],[0,";\n  "]],"start1":1947,"start2":1947,"length1":37,"length2":21},{"diffs":[[0,"65;\n        "],[-1,"    "],[0,"rSpeed = lSp"]],"start1":1962,"start2":1962,"length1":28,"length2":24},{"diffs":[[0,"d = "],[-1,"lSpeed;\n        }\n    }\n\n    serial.writeLine(Math.roundWithPrecision(lSpeed, 3).toString() + \", \" + Math.roundWithPrecision(upVector, 2).toString() + \", \" + Math.roundWithPrecision(forwardVector, 2).toString());"],[1,"0.65;\n    }"],[0,"\n\n  "]],"start1":1979,"start2":1979,"length1":220,"length2":19}]}]},{"timestamp":1739044582844,"editorVersion":"7.0.57","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"= deltaTime * 0."],[-1,"4"],[1,"1"],[0,";\n            rS"]],"start1":1768,"start2":1768,"length1":33,"length2":33},{"diffs":[[0,"ime * 0."],[-1,"4"],[1,"1"],[0,";\n      "]],"start1":1902,"start2":1902,"length1":17,"length2":17},{"diffs":[[0,"ine("],[-1,"segment.toString() + \", \" + "],[0,"Math"]],"start1":1976,"start2":1976,"length1":36,"length2":8}]}]},{"timestamp":1739045143581,"editorVersion":"7.0.57","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"20\n\n"],[-1,"\nlet segment = 0; // 0 = calibration, 1 = button drive\nlet calibrationCountdown = 3;\nlet calibrationLoops = 0;\nlet calibAvgForwardVector = 0;\nlet calibAvgUpVector = 0;\n\n"],[0,"let "]],"start1":269,"start2":269,"length1":177,"length2":8},{"diffs":[[0,"arDist = 0;\n"],[-1,"\n"],[0,"let upVector"]],"start1":280,"start2":280,"length1":25,"length2":24},{"diffs":[[0,"ector = 0;\n\n"],[1,"let segment = 0; // 0 = calibration, 1 = button drive\nlet calibrationCountdown = 3;\nlet calibrationLoops = 0;\n"],[0,"let avgForwa"]],"start1":322,"start2":322,"length1":24,"length2":134},{"diffs":[[0,"Vector = 0;\n"],[-1,"\n"],[0,"let forwardV"]],"start1":479,"start2":479,"length1":25,"length2":24},{"diffs":[[0,"0;\n\n"],[-1,"let vectorsList = [[0, 0, 0, 0], [0, 0 ,0, 0]];\n\n"],[0,"whil"]],"start1":541,"start2":541,"length1":57,"length2":8},{"diffs":[[0,"ine("],[-1,"vectorsList[0].length"],[1,"segment"],[0,".toS"]],"start1":1976,"start2":1976,"length1":29,"length2":15},{"diffs":[[0,"ion("],[-1,"avgForwardVector, 2"],[1,"lSpeed, 3).toString("],[0,") + "]],"start1":2028,"start2":2028,"length1":27,"length2":28},{"diffs":[[0,"ecision("],[-1,"avgU"],[1,"u"],[0,"pVector,"]],"start1":2079,"start2":2079,"length1":20,"length2":17},{"diffs":[[0,", 2)"],[-1," + \", \" + segment"],[1,".toString() + \", \" + Math.roundWithPrecision(forwardVector, 2)"],[0,".toS"]],"start1":2095,"start2":2095,"length1":25,"length2":70},{"diffs":[[0,"forward\n"],[1,""],[0,"    // l"]],"start1":2686,"start2":2686,"length1":16,"length2":16},{"diffs":[[0,"tor)"],[-1,"\n\n    for (let i = 3; i > 0; i -= 1){\n        vectorsList[0][i] = vectorsList[0][i - 1]\n        vectorsList[1][i] = vectorsList[1][i - 1]\n    }\n\n    vectorsList[0][0] = forwardVector;\n    vectorsList[1][0] = upVector;\n\n    avgForwardVector = 0;\n    avgUpVector = 0;\n\n    for (let i = 0; i < 4; i++){\n        avgForwardVector += vectorsList[0][i];\n        avgUpVector += vectorsList[1][i];\n    }\n    avgForwardVector /= 4;\n    avgUpVector /= 4;"],[0,"\n}\n\n"]],"start1":2737,"start2":2737,"length1":451,"length2":8}]}]},{"timestamp":1739045737782,"editorVersion":"7.0.57","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"];\n\n"],[-1,"led.setDisplayMode(DisplayMode.BlackAndWhite);\n\n"],[0,"whil"]],"start1":651,"start2":651,"length1":56,"length2":8},{"diffs":[[0,"    "],[-1,"// calibrating\n                led.plot(4, 0);\n\n                calibA"],[1,"a"],[0,"vgFo"]],"start1":1246,"start2":1246,"length1":78,"length2":9},{"diffs":[[0,"                "],[-1,"calibA"],[1,"a"],[0,"vgUpVector += up"]],"start1":1285,"start2":1285,"length1":38,"length2":33},{"diffs":[[0,"        "],[-1,"calibA"],[1,"a"],[0,"vgForwar"]],"start1":1507,"start2":1507,"length1":22,"length2":17},{"diffs":[[0,"        "],[-1,"calibA"],[1,"a"],[0,"vgUpVect"]],"start1":1565,"start2":1565,"length1":22,"length2":17},{"diffs":[[0,"fset = -"],[-1,"calibA"],[1,"a"],[0,"vgForwar"]],"start1":1662,"start2":1662,"length1":22,"length2":17},{"diffs":[[0,"fset = -"],[-1,"calibA"],[1,"a"],[0,"vgUpVect"]],"start1":1718,"start2":1718,"length1":22,"length2":17},{"diffs":[[0,"   }"],[-1," else {\n                // show countdown\n                led.plot(3 - Math.round(calibrationCountdown), 0);\n            }\n        } else {\n            // Press button A to calibrate"],[0,"\n   "]],"start1":1766,"start2":1766,"length1":190,"length2":8},{"diffs":[[0,"1){\n"],[-1,"        // Running\n"],[0,"    "]],"start1":1807,"start2":1807,"length1":27,"length2":8},{"diffs":[[0,"iteLine("],[1,"vectorsList[0].length.toString() + \", \" + "],[0,"Math.rou"]],"start1":2082,"start2":2082,"length1":16,"length2":58}]}]},{"timestamp":1739046336924,"editorVersion":"7.0.57","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"is -20\n\n"],[1,"\n"],[0,"let segm"]],"start1":265,"start2":265,"length1":16,"length2":17},{"diffs":[[0,"rive"],[-1,"\n\n// Calibration variables"],[0,"\nlet"]],"start1":323,"start2":323,"length1":34,"length2":8},{"diffs":[[0,"0;\n\n"],[-1,"// Global variables //\n// Sonar\n"],[0,"let "]],"start1":438,"start2":438,"length1":40,"length2":8},{"diffs":[[0,"0;\n\n"],[-1,"// Accelerometer\n"],[0,"let "]],"start1":458,"start2":458,"length1":25,"length2":8},{"diffs":[[0,"];\n\n"],[-1,"// Position\nlet x = 0;\nlet y = 0;\nlet x"],[1,"led.setDisplayMode(DisplayMode.BlackAndWhite);"],[0,"\n\nwh"]],"start1":651,"start2":651,"length1":47,"length2":54},{"diffs":[[0,"  //"],[-1," Show blinking dot for"],[0," cal"]],"start1":1296,"start2":1296,"length1":30,"length2":8},{"diffs":[[0,"    "],[-1,"if (Math.round(time / 0.7) % 2){\n                    led.plot(1, 0);\n                } else {\n                    led.unplot(1, 0);\n                }"],[1,"led.plot(4, 0);"],[0,"\n\n  "]],"start1":1325,"start2":1325,"length1":157,"length2":23},{"diffs":[[0,"s > "],[-1,"50){ // Do 50 (or maybe 51 I don't care) loops"],[1,"100){\n                    segment++; // Stops calibrating and moves on\n                    "],[0,"\n   "]],"start1":1521,"start2":1521,"length1":54,"length2":99},{"diffs":[[0,"tor;"],[-1,"\n\n                    segment++; // Stops calibrating and moves on\n                    led.plot(1, 0); // Light to show calibration done"],[0,"\n   "]],"start1":1876,"start2":1876,"length1":144,"length2":8},{"diffs":[[0,"down"],[-1," + 0.5) + 2"],[1,")"],[0,", 0)"]],"start1":2010,"start2":2010,"length1":19,"length2":9},{"diffs":[[0,"ate\n"],[-1,"            led.plot(0, 0);\n"],[0,"    "]],"start1":2091,"start2":2091,"length1":36,"length2":8},{"diffs":[[0,"    "],[-1,"led.plot(0, 1);\n"],[1,"if (input.buttonIsPressed(Button.A)) {\n            lSpeed += deltaTime * 0.4;\n            rSpeed = lSpeed;\n        }\n\n        if (input.buttonIsPressed(Button.B)) {\n            lSpeed -= deltaTime * 0.4;\n            rSpeed = lSpeed;"],[0,"\n   "]],"start1":2158,"start2":2158,"length1":24,"length2":240},{"diffs":[[0,"ed;\n        "],[1,"}"],[0,"\n    }\n\n    "]],"start1":2391,"start2":2391,"length1":24,"length2":25}]}]},{"timestamp":1739046933735,"editorVersion":"7.0.57","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"= 0;"],[-1,"\nlet calibAvgXVector = 0;"],[0,"\n\n//"]],"start1":461,"start2":461,"length1":33,"length2":8},{"diffs":[[0,"rometer\nlet "],[-1,"forward"],[1,"up"],[0,"Vector = 0;\n"]],"start1":528,"start2":528,"length1":31,"length2":26},{"diffs":[[0,"let "],[-1,"upVector = 0;\nlet x"],[1,"forward"],[0,"Vect"]],"start1":554,"start2":554,"length1":27,"length2":15},{"diffs":[[0,"= 0;"],[-1,"\nlet avgXVector = 0;"],[0,"\n\nle"]],"start1":620,"start2":620,"length1":28,"length2":8},{"diffs":[[0,"= 0;"],[-1,"\nlet xVectorOffset = 0;"],[0,"\n\nle"]],"start1":674,"start2":674,"length1":31,"length2":8},{"diffs":[[0,"], [0, 0"],[-1,", 0, 0], [0, 0,"],[0," "],[1,","],[0,"0, 0]];\n"]],"start1":710,"start2":710,"length1":32,"length2":18},{"diffs":[[0,"et x"],[-1,"Vel = 0;\nlet yVel = 0;"],[0,"\n\nwh"]],"start1":764,"start2":764,"length1":30,"length2":8},{"diffs":[[0,"tor;"],[-1,"\n                calibAvgXVector += xVector;"],[0,"\n\n  "]],"start1":1666,"start2":1666,"length1":52,"length2":8},{"diffs":[[0,"Loops > "],[-1,"10"],[1,"5"],[0,"0){ // D"]],"start1":1740,"start2":1740,"length1":18,"length2":17},{"diffs":[[0,"ps;\n"],[-1,"                    calibAvgXVector /= calibrationLoops;\n"],[0,"    "]],"start1":1912,"start2":1912,"length1":65,"length2":8},{"diffs":[[0,"tor;"],[-1,"\n                    xVectorOffset = -calibAvgXVector;"],[0,"\n\n  "]],"start1":2054,"start2":2054,"length1":62,"length2":8},{"diffs":[[0,"    "],[-1,"// Gravity is 9.8m/s, and 1024 = gravity on this\n        // So if we take the accelerometer reading and divide by 1024, and multiply by 9.8\n        // Than we should be in meters per second\n        // 9.8/1024 is 0.0095703125\n        xVel = xVector * 0.0095703125;\n        yVel = forwardVector * 0.0095703125;\n\n        x += xVel * deltaTime;\n        y += yVel * deltaTime;"],[0,"\n   "]],"start1":2535,"start2":2535,"length1":380,"length2":8},{"diffs":[[0,"  }\n\n   "],[-1," //"],[0," serial."]],"start1":2542,"start2":2542,"length1":19,"length2":16},{"diffs":[[0,"\" + "],[-1,"Math.roundWithPrecision(avgXVector, 2) + \", \" + segment.toString());\n    serial.writeLine(Math.roundWithPrecision(x, 3).toString() + \", \" + Math.roundWithPrecision(y, 3).toString())"],[1,"segment.toString());"],[0,"\n\n  "]],"start1":2667,"start2":2667,"length1":189,"length2":28},{"diffs":[[0,"ard\n"],[-1,"    xVector = xA + xVectorOffset;\n"],[0,"    "]],"start1":3207,"start2":3207,"length1":42,"length2":8},{"diffs":[[0," 1]\n"],[-1,"        vectorsList[2][i] = vectorsList[2][i - 1]\n"],[0,"    "]],"start1":3392,"start2":3392,"length1":58,"length2":8},{"diffs":[[0,"tor;"],[-1,"\n    vectorsList[2][0] = xA;"],[0,"\n\n  "]],"start1":3471,"start2":3471,"length1":36,"length2":8},{"diffs":[[0,"= 0;"],[-1,"\n    avgXVector = 0;"],[0,"\n\n  "]],"start1":3519,"start2":3519,"length1":28,"length2":8},{"diffs":[[0,"i];\n"],[-1,"        avgXVector += vectorsList[2][i];\n"],[0,"    "]],"start1":3643,"start2":3643,"length1":49,"length2":8},{"diffs":[[0," 4;\n"],[-1,"    avgXVector /= 4;\n"],[0,"}\n\nf"]],"start1":3698,"start2":3698,"length1":29,"length2":8}]}]},{"timestamp":1739047482208,"editorVersion":"7.0.57","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0," 0;\n"],[-1,"let frame = 0; // To do something every few frames\n"],[0,"cons"]],"start1":97,"start2":97,"length1":59,"length2":8},{"diffs":[[0,"ime;"],[-1,"\n    frame++;"],[0,"\n\n  "]],"start1":1000,"start2":1000,"length1":21,"length2":8},{"diffs":[[0,"ation();\n   "],[-1," //"],[0," sonarDist ="]],"start1":1057,"start2":1057,"length1":27,"length2":24},{"diffs":[[0,"r();\n   "],[-1," //"],[0," sonarDi"]],"start1":1097,"start2":1097,"length1":19,"length2":16},{"diffs":[[0," Running"],[1,"\n        led.plot(0, 1);"],[0,"\n\n      "]],"start1":2774,"start2":2774,"length1":16,"length2":40},{"diffs":[[0,"125\n"],[-1,"        // Add acceleration to velocity\n"],[0,"    "]],"start1":3038,"start2":3038,"length1":48,"length2":8},{"diffs":[[0,"   xVel "],[-1,"+"],[0,"= xVecto"]],"start1":3047,"start2":3047,"length1":17,"length2":16},{"diffs":[[0,"   yVel "],[-1,"+"],[0,"= forwar"]],"start1":3086,"start2":3086,"length1":17,"length2":16},{"diffs":[[0,"5;\n\n"],[-1,"        // Add velocity to position\n"],[0,"    "]],"start1":3123,"start2":3123,"length1":44,"length2":8},{"diffs":[[0,"    "],[-1,"if (frame % 60 == 0){\n        serial.writeLine(Math.round(1/deltaTime).toString() + \", \" + "],[1,"serial.writeLine("],[0,"Math"]],"start1":3392,"start2":3392,"length1":99,"length2":25},{"diffs":[[0,"tring())"],[-1,";\n    }"],[0,"\n\n   "],[-1," //"],[0," driveMo"]],"start1":3496,"start2":3496,"length1":31,"length2":21},{"diffs":[[0,"ons\n"],[-1,"    control.waitMicros(1000000/300);\n"],[0,"    "]],"start1":3564,"start2":3564,"length1":45,"length2":8}]}]},{"timestamp":1739048046853,"editorVersion":"7.0.57","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0," 0;\n"],[-1,"let calibrationsToDo = 0;\n"],[0,"let "]],"start1":456,"start2":456,"length1":34,"length2":8},{"diffs":[[0,"wardVector = 0;\n"],[1,""],[0,"let calibAvgUpVe"]],"start1":475,"start2":475,"length1":32,"length2":32},{"diffs":[[0,"me;\n"],[-1,"            calibrationsToDo = Math.round(1 / deltaTime) * 3; // 3 seconds worth\n"],[0,"    "]],"start1":1365,"start2":1365,"length1":89,"length2":8},{"diffs":[[0,"s > "],[-1,"calibrationsToDo){ // Do 3 second's worth of"],[1,"100){ // Do 50 (or maybe 51 I don't care)"],[0," loo"]],"start1":1979,"start2":1979,"length1":52,"length2":49},{"diffs":[[0," Running"],[1,"\n\n        // Gravity is 9.8m/s, and 1024 = gravity on this\n        // So if we take the accelerometer reading and divide by 1024, and multiply by 9.8\n        // Than we should be in meters per second\n        // 9.8/1024 is 0.0095703125\n        // Add acceleration to velocity\n        xVel += xVector * 0.0095703125;\n        yVel += forwardVector * 0.0095703125;\n\n        // Add velocity to position\n        x += xVel * deltaTime;\n        y += yVel * deltaTime;"],[0,"\n    }\n\n"]],"start1":2844,"start2":2844,"length1":16,"length2":476},{"diffs":[[0,"1000000/"],[-1,"4"],[1,"3"],[0,"00);\n   "]],"start1":3799,"start2":3799,"length1":17,"length2":17}]}]},{"timestamp":1739048337698,"editorVersion":"7.0.57","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"ation();\n   "],[1," //"],[0," sonarDist ="]],"start1":1147,"start2":1147,"length1":24,"length2":27},{"diffs":[[0,"r();\n   "],[1," //"],[0," sonarDi"]],"start1":1190,"start2":1190,"length1":16,"length2":19},{"diffs":[[0,"ning"],[-1,"\n\n        lSpeed = 0.6;\n        rSpeed = 0.6;\n\n        if (s)"],[0,"\n   "]],"start1":2958,"start2":2958,"length1":69,"length2":8}]}]},{"timestamp":1739048937649,"editorVersion":"7.0.57","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"= 0;"],[-1,"\nlet rotation = 0; // in radians, 0deg = positive x (cos(a)*m = x, sin(a)*m = y)"],[0,"\n\nwh"]],"start1":962,"start2":962,"length1":88,"length2":8},{"diffs":[[0,"f (s"],[-1,"onarDist < 50){\n            lSpeed = -0.6;\n            \n        } else {\n            x += lSpeed * Math.cos(rotation);\n            y += lSpeed * Math.sin(rotation);\n        }"],[1,")"],[0,"\n   "]],"start1":3012,"start2":3012,"length1":182,"length2":9},{"diffs":[[0,"e % "],[-1,"Math.round((1 / deltaTime) / 4) == 0){ // 4 times per second, serial"],[1,"60 == 0){"],[0,"\n   "]],"start1":3233,"start2":3233,"length1":76,"length2":17},{"diffs":[[0," + \""],[-1,"fps"],[0,", \" "]],"start1":3306,"start2":3306,"length1":11,"length2":8},{"diffs":[[0,"\n    }\n\n"],[-1,""],[0,"   "],[1," //"],[0," driveMo"]],"start1":3408,"start2":3408,"length1":19,"length2":22}]}]},{"timestamp":1739049536591,"editorVersion":"7.0.57","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"ed = -0."],[-1,"3"],[1,"6"],[0,";\n      "]],"start1":3128,"start2":3128,"length1":17,"length2":17},{"diffs":[[0,"    "],[-1,"rSpeed = 0.3;\n\n    //         // 1.36s? for a full rotation\n    //         rotation += -deltaTime/1.36 * 2 * Math.PI; // 360 degress in 1.36 seconds\n    //"],[1,"\n   "],[0,"    "]],"start1":3147,"start2":3147,"length1":163,"length2":12},{"diffs":[[0,"} else {\n   "],[-1," //"],[0,"         x +"]],"start1":3160,"start2":3160,"length1":27,"length2":24},{"diffs":[[0,"tation);\n   "],[-1," //"],[0,"         y +"]],"start1":3206,"start2":3206,"length1":27,"length2":24},{"diffs":[[0,"n);\n"],[-1,"    //     }\n"],[0,"    "]],"start1":3257,"start2":3257,"length1":21,"length2":8}]}]},{"timestamp":1739049873841,"editorVersion":"7.0.57","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"Speed = 0.3;"],[1,"\n\n    //         // 1.36s? for a full rotation\n    //         rotation += -deltaTime/1.36 * 2 * Math.PI; // 360 degress in 1.36 seconds\n    //     } else {\n    //         x += lSpeed * Math.cos(rotation);\n    //         y += lSpeed * Math.sin(rotation);\n    //     }"],[0,"\n        }\n "]],"start1":3152,"start2":3152,"length1":24,"length2":290}]}]},{"timestamp":1739053270765,"editorVersion":"7.0.57","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0," // Running\n"],[1,"\n"],[0,"        lSpe"]],"start1":3025,"start2":3025,"length1":24,"length2":25}]}]},{"timestamp":1739053280057,"editorVersion":"7.0.57","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[-1,"// Variables for time, delta time, and fps\n"],[0,"let "]],"start1":0,"start2":0,"length1":47,"length2":4},{"diffs":[[0,"5;\n\n"],[-1,"// Global variables //\n// Calibration variables\nlet isCalibrating = false;\nconst calibrationSamples = 50;"],[1,"let lSpeed = 0;\nlet rSpeed = 0;\n// if going backwards, speed is just regular out of 100, minus 100\n// so 20 backwards is -80\n// 80 backwards is -20\n\nlet segment = 0; // 0 = calibration, 1 = button drive\n\n// Calibration variables"],[0,"\nlet"]],"start1":171,"start2":171,"length1":113,"length2":236},{"diffs":[[0,"nLoops = 0;\n"],[1,"let calibrationsToDo = 0;\n"],[0,"let calibAvg"]],"start1":448,"start2":448,"length1":24,"length2":50},{"diffs":[[0,"\n// "],[-1,"Segment\nlet segment = 0; // 0 = calibration, 1 = button drive\n\n// Motors\nlet lSpeed = 0;\nlet rSpeed = 0;\n"],[1,"Global variables //"],[0,"\n// "]],"start1":568,"start2":568,"length1":113,"length2":27},{"diffs":[[0,"time"],[-1,", delta time, and frame number"],[0,"\n   "]],"start1":1076,"start2":1076,"length1":38,"length2":8},{"diffs":[[0," // "],[-1,"Update sonar and acceleration"],[1,"Inputs and"],[0," mea"]],"start1":1179,"start2":1179,"length1":37,"length2":18},{"diffs":[[0,"n();"],[-1," // Function that updates acceleration and the vectors"],[0,"\n   "]],"start1":1231,"start2":1231,"length1":62,"length2":8},{"diffs":[[0,"r();"],[-1," // Get output, max of 150"],[0,"\n   "],[-1," //"],[0," son"]],"start1":1267,"start2":1267,"length1":41,"length2":12},{"diffs":[[0,"ist;"],[-1," // This would make it 150 if = 0\n\n    // Handle each segment\n    if (segment == 0){ // Calibration/wait for calibration\n        if (!isCalibrating && input.buttonIsPressed(Button.A)) { // If not calibrating, and A is pressed"],[1,"\n\n    if (segment == 0){\n        if (input.buttonIsPressed(Button.A) && calibrationCountdown == 3) {\n            calibrationCountdown -= deltaTime;"],[0,"\n   "]],"start1":1317,"start2":1317,"length1":233,"length2":155},{"diffs":[[0,"    "],[-1,"isC"],[1,"c"],[0,"alibrati"],[-1,"ng = true; // Start calibrating"],[1,"onsToDo = Math.round(1 / deltaTime) * 3; // 3 seconds worth"],[0,"\n   "]],"start1":1477,"start2":1477,"length1":50,"length2":76},{"diffs":[[0,"tion"],[-1,"Samples"],[1,"sToDo"],[0,"){ /"]],"start1":2171,"start2":2171,"length1":15,"length2":13},{"diffs":[[0,"   }\n    }\n\n"],[1,"    // serial.writeLine(Math.roundWithPrecision(avgForwardVector, 2) + \", \" + Math.roundWithPrecision(avgUpVector, 2) + \", \" + Math.roundWithPrecision(avgXVector, 2) + \", \" + segment.toString());\n"],[0,"    if (fram"]],"start1":3169,"start2":3169,"length1":24,"length2":220}]}]},{"timestamp":1739053873993,"editorVersion":"7.0.57","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"ibration"],[-1,"SamplesDone"],[1,"Loops"],[0," = 0;\nle"]],"start1":361,"start2":361,"length1":27,"length2":21},{"diffs":[[0,"  } "],[-1,"\n        \n        if (isCalibrating){ // Basically, if the button was pressed\n            if (calibrationCountdown > 0){ // If the countdown hasn't reached zero\n                calibrationCountdown -= deltaTime; // Increment calibration countdown\n                led.plot(3 - Math.round(calibrationCountdown + 0.5) + 2, 0); // Show countdown as 3 dots\n            } else { // Countdown complete, and calibration is happening"],[1,"else if (calibrationCountdown != 3){\n            calibrationCountdown -= deltaTime;\n\n            if (calibrationCountdown <= 0){\n                // Calibration!"],[0,"\n   "]],"start1":1720,"start2":1720,"length1":432,"length2":168},{"diffs":[[0,"/ 0."],[-1,"5"],[1,"7"],[0,") % 2)"],[-1," { // Fancy math to blink every 0.5 seconds"],[1,"{"],[0,"\n   "]],"start1":1974,"start2":1974,"length1":58,"length2":16},{"diffs":[[0," }\n\n"],[-1,"                // Add a sample to the average\n"],[0,"    "]],"start1":2101,"start2":2101,"length1":55,"length2":8},{"diffs":[[0,"    "],[-1,"// Keep track of how many calibration samples added\n                calibrationSamplesDone"],[1,"calibrationLoops"],[0,"++;\n"]],"start1":2264,"start2":2264,"length1":98,"length2":24},{"diffs":[[0,"tion"],[-1,"SamplesDone"],[1,"Loops"],[0," >"],[-1,"="],[0," cal"]],"start1":2316,"start2":2316,"length1":22,"length2":15},{"diffs":[[0,"les)"],[-1," "],[0,"{ // "],[-1,"If we have done the number of samples we need, than divide to get the average"],[1,"Do 3 second's worth of loops"],[0,"\n   "]],"start1":2343,"start2":2343,"length1":91,"length2":41},{"diffs":[[0," calibration"],[-1,"SamplesDone"],[1,"Loops"],[0,";\n          "]],"start1":2425,"start2":2425,"length1":35,"length2":29},{"diffs":[[0,"ibration"],[-1,"SamplesDone"],[1,"Loops"],[0,";\n      "]],"start1":2487,"start2":2487,"length1":27,"length2":21},{"diffs":[[0,"tion"],[-1,"SamplesDone;\n"],[1,"Loops;"],[0,"\n   "]],"start1":2548,"start2":2548,"length1":21,"length2":14},{"diffs":[[0,"    "],[-1,"// The average is the offset we need to correct for"],[0,"\n   "]],"start1":2575,"start2":2575,"length1":59,"length2":8},{"diffs":[[0," // "],[-1,"Goes to the next part of executi"],[1,"Stops calibrating and moves "],[0,"on\n "]],"start1":2787,"start2":2787,"length1":40,"length2":36},{"diffs":[[0,"              }\n"],[1,"            } else {\n                // show countdown\n                led.plot(3 - Math.round(calibrationCountdown + 0.5) + 2, 0);\n"],[0,"            }\n  "]],"start1":2894,"start2":2894,"length1":32,"length2":164}]}]},{"timestamp":1739054450185,"editorVersion":"7.0.57","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"tion"],[-1," (\"Running\")"],[0,"\n   "]],"start1":3381,"start2":3381,"length1":20,"length2":8},{"diffs":[[0,"to show "],[-1,"that "],[0,"calibrat"]],"start1":3431,"start2":3431,"length1":21,"length2":16},{"diffs":[[0,"tion"],[-1,"'s"],[0," don"]],"start1":3446,"start2":3446,"length1":10,"length2":8},{"diffs":[[0,"se {"],[-1," // Not"],[1,"\n            // Press button A to"],[0," cal"]],"start1":3500,"start2":3500,"length1":15,"length2":41},{"diffs":[[0,"on A to calibrat"],[-1,"ing"],[1,"e"],[0,"\n            led"]],"start1":3530,"start2":3530,"length1":35,"length2":33},{"diffs":[[0," 0);"],[-1," // Just turn on the led"],[0,"\n   "]],"start1":3571,"start2":3571,"length1":32,"length2":8},{"diffs":[[0,"0){\n"],[-1,"            // Turn left\n"],[0,"    "]],"start1":3705,"start2":3705,"length1":33,"length2":8},{"diffs":[[0,".3;\n"],[-1,"\n            // Show led turning left\n            led.plot(4, 2);\n            led.unplot(2, 2);\n        } else {\n            // Show led center\n            led.plot(2, 2);\n            led.unplot(4, 2);\n        }\n    }\n\n     // 4 times per second, write something to serial"],[1,"        }\n    }\n"],[0,"\n   "]],"start1":3758,"start2":3758,"length1":280,"length2":24},{"diffs":[[0,") == 0){"],[1," // 4 times per second, serial"],[0,"\n       "]],"start1":3825,"start2":3825,"length1":16,"length2":46},{"diffs":[[0,"\"fps"],[-1,"\");\n        // Prints fps\n    }\n\n    driveMotors(); // Takes lSpeed and rSpeed and makes the motors turn\n\n    // Update for delta time calcualtions\n    lastTime = time;\n}\n\n// This takes the raw acceleration and turns it into vectors (up, forward, and x (which is right/left))"],[1,", \" + Math.roundWithPrecision(x, 3).toString() + \", \" + Math.roundWithPrecision(y, 3).toString());\n    }\n\n    driveMotors();\n\n    // Update for delta time calcualtions\n    control.waitMicros(1000000/400);\n    lastTime = time;\n}\n"],[0,"\nfun"]],"start1":3926,"start2":3926,"length1":283,"length2":236},{"diffs":[[0,");\n\n"],[-1,"    // Fancy maths\n"],[0,"    "]],"start1":4328,"start2":4328,"length1":27,"length2":8},{"diffs":[[0," gravity"],[-1," 1024"],[0,")\n    fo"]],"start1":4459,"start2":4459,"length1":21,"length2":16},{"diffs":[[0,"set;"],[-1," // Side to side acceleration\n\n    // Shift the "],[1,"\n    // let movementAngle = Math.atan2(upVector)\n"],[0,"\n   "]],"start1":4620,"start2":4620,"length1":56,"length2":57}]}]},{"timestamp":1739055048317,"editorVersion":"7.0.57","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[-1,"//"],[0,"// Varia"]],"start1":0,"start2":0,"length1":10,"length2":8},{"diffs":[[0," and fps"],[-1," ////"],[0,"\nlet las"]],"start1":34,"start2":34,"length1":21,"length2":16},{"diffs":[[0," 25;\n\n//"],[1," Global variables //\n"],[0,"// Calib"]],"start1":212,"start2":212,"length1":16,"length2":37},{"diffs":[[0,"ariables"],[-1," ////"],[0,"\nlet isC"]],"start1":257,"start2":257,"length1":21,"length2":16},{"diffs":[[0,"= 0;"],[-1,"\n\n// Used as temporary variables to add for each sample, which are then divided by the number of samples to get the average"],[0,"\nlet"]],"start1":381,"start2":381,"length1":131,"length2":8},{"diffs":[[0,"tors"],[-1," speed"],[0,"\nlet"]],"start1":540,"start2":540,"length1":14,"length2":8},{"diffs":[[0,"t = 0;\n\n"],[-1,"//"],[0,"// Accel"]],"start1":599,"start2":599,"length1":18,"length2":16},{"diffs":[[0,"eter"],[-1," ////"],[0,"\nlet"]],"start1":619,"start2":619,"length1":13,"length2":8},{"diffs":[[0,"0;\n\n"],[-1,"// This updates every frame - it's the average of the last 4 \n"],[0,"let "]],"start1":679,"start2":679,"length1":70,"length2":8},{"diffs":[[0,"the "],[-1,"list of vectors so that you can update the first one"],[0,"\n   "]],"start1":5009,"start2":5009,"length1":60,"length2":8},{"diffs":[[0,"A;\n\n"],[-1,"    // Find the average of each of the last 4 vectors\n"],[0,"    "]],"start1":5305,"start2":5305,"length1":62,"length2":8}]}]},{"timestamp":1739055489237,"editorVersion":"7.0.57","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"ive\n"],[-1,"const CALIBRATING = 0;\nconst RUNNING = 1;\n\n// Motors speed\nlet lSpeed = 0; // Left motor speed (between -1 and 1)\nlet rSpeed = 0; // Right motor speed (between -1 and 1)"],[1,"\n// Motors speed\nlet lSpeed = 0;\nlet rSpeed = 0;"],[0,"\n\n//"]],"start1":644,"start2":644,"length1":177,"length2":56},{"diffs":[[0,"e last 4"],[1," "],[0,"\nlet avg"]],"start1":862,"start2":862,"length1":16,"length2":17},{"diffs":[[0,"0;\n\n"],[-1,"// These are used to keep it calibrated\n"],[0,"let "]],"start1":936,"start2":936,"length1":48,"length2":8},{"diffs":[[0,"0;\n\n"],[-1,"// This stores the last 4 of each vector\n"],[0,"let "]],"start1":1013,"start2":1013,"length1":49,"length2":8},{"diffs":[[0,"];\n\n"],[-1,"// Not doing position right now\n// "],[0,"// P"]],"start1":1076,"start2":1076,"length1":43,"length2":8},{"diffs":[[0,"osition\n"],[-1,"// "],[0,"let x = "]],"start1":1084,"start2":1084,"length1":19,"length2":16},{"diffs":[[0,"\nlet x = 0;\n"],[-1,"// "],[0,"let y = 0;\n/"]],"start1":1091,"start2":1091,"length1":27,"length2":24},{"diffs":[[0,"\nlet y = 0;\n"],[-1,"// "],[0,"let xVel = 0"]],"start1":1102,"start2":1102,"length1":27,"length2":24},{"diffs":[[0,"t xVel = 0;\n"],[-1,"// "],[0,"let yVel = 0"]],"start1":1116,"start2":1116,"length1":27,"length2":24},{"diffs":[[0,"el = 0;\n"],[-1,"// "],[0,"let rota"]],"start1":1134,"start2":1134,"length1":19,"length2":16},{"diffs":[[0,"000;"],[-1," // This is the current time in seconds"],[0,"\n   "]],"start1":1329,"start2":1329,"length1":47,"length2":8},{"diffs":[[0,"ime;"],[-1," // This is the frame time"],[0,"\n   "]],"start1":1362,"start2":1362,"length1":34,"length2":8},{"diffs":[[0," of 150\n"],[-1,"\n"],[0,"    // s"]],"start1":1568,"start2":1568,"length1":17,"length2":16},{"diffs":[[0,"e it"],[-1," ="],[0," 150 if "],[-1,"sonarDist "],[0,"= 0\n"]],"start1":1646,"start2":1646,"length1":28,"length2":16},{"diffs":[[0," == "],[-1,"CALIBRATING"],[1,"0"],[0,"){ /"]],"start1":1705,"start2":1705,"length1":19,"length2":9},{"diffs":[[0,"rating){"],[1," // Basically, if the button was pressed"],[0,"\n       "]],"start1":1948,"start2":1948,"length1":16,"length2":56},{"diffs":[[0,"       }"],[-1,"\n           "],[0," else { "]],"start1":2276,"start2":2276,"length1":28,"length2":16},{"diffs":[[0,"            "],[1," if (calibrationSamplesDone >= calibrationSamples) {"],[0," // If we ha"]],"start1":2914,"start2":2914,"length1":24,"length2":76},{"diffs":[[0,"age\n"],[-1,"                if (calibrationSamplesDone >= calibrationSamples) {\n"],[0,"    "]],"start1":3056,"start2":3056,"length1":76,"length2":8},{"diffs":[[0,"       }"],[-1,"\n       "],[0," else { "]],"start1":3697,"start2":3697,"length1":24,"length2":16},{"diffs":[[0," == "],[-1,"RUNNING){"],[1,"1){\n        // Running\n        lSpeed = 0.6;\n        rSpeed = 0.6;\n"],[0,"\n   "]],"start1":3816,"start2":3816,"length1":17,"length2":75},{"diffs":[[0,"e {\n"],[-1,"            // Go forward\n            lSpeed = 0.6;\n            rSpeed = 0.6;\n\n"],[0,"    "]],"start1":4104,"start2":4104,"length1":87,"length2":8},{"diffs":[[0," }\n\n    "],[1," "],[0,"// 4 tim"]],"start1":4210,"start2":4210,"length1":16,"length2":17},{"diffs":[[0,"0){\n"],[-1,"        // Prints fps\n"],[0,"    "]],"start1":4319,"start2":4319,"length1":30,"length2":8},{"diffs":[[0,"\"fps\");\n"],[1,"        // Prints fps\n"],[0,"    }\n\n "]],"start1":4385,"start2":4385,"length1":16,"length2":38}]}]},{"timestamp":1739055931285,"editorVersion":"7.0.57","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0," of 150\n"],[1,"\n"],[0,"   "],[1," //"],[0," sonarDi"]],"start1":1884,"start2":1884,"length1":19,"length2":23},{"diffs":[[0,"// This "],[1,"would "],[0,"make"],[-1,"s"],[0," it = 15"]],"start1":1946,"start2":1946,"length1":21,"length2":26},{"diffs":[[0,"left\n           "],[-1," //"],[0," lSpeed = -0.3;\n"]],"start1":4214,"start2":4214,"length1":35,"length2":32},{"diffs":[[0,"0.3;\n           "],[-1," //"],[0," rSpeed = 0.3;\n\n"]],"start1":4241,"start2":4241,"length1":35,"length2":32},{"diffs":[[0,"        "],[-1," //"],[0," lSpeed "]],"start1":4414,"start2":4414,"length1":19,"length2":16},{"diffs":[[0,"eed = 0."],[-1,"3"],[1,"6"],[0,";\n      "]],"start1":4426,"start2":4426,"length1":17,"length2":17},{"diffs":[[0,"        "],[-1," //"],[0," rSpeed "]],"start1":4440,"start2":4440,"length1":19,"length2":16},{"diffs":[[0,"     rSpeed = 0."],[-1,"3"],[1,"6"],[0,";\n\n            /"]],"start1":4444,"start2":4444,"length1":33,"length2":33},{"diffs":[[0," // "],[-1,"Print to serial\n"],[1,"4 times per second, write something to serial\n    if (frame % Math.round((1 / deltaTime) / 4) == 0){\n        // Prints fps\n    "],[0,"    "]],"start1":4573,"start2":4573,"length1":24,"length2":135},{"diffs":[[0,"\"fps"],[-1,", \" + sonarDist.toString());"],[1,"\");\n    }"],[0,"\n\n  "]],"start1":4762,"start2":4762,"length1":36,"length2":17},{"diffs":[[0,"me;\n"],[1,""],[0,"}\n\n"],[-1,"\n"],[0,"// T"]],"start1":4909,"start2":4909,"length1":12,"length2":11},{"diffs":[[0,"= 4;\n}\n\n"],[1,"function driveMotors(){\n    "],[0,"// Calcu"]],"start1":6261,"start2":6261,"length1":16,"length2":44},{"diffs":[[0,"ive\n"],[-1,"function driveMotors(){\n"],[0,"    "]],"start1":6350,"start2":6350,"length1":32,"length2":8}]}]},{"timestamp":1739056428191,"editorVersion":"7.0.57","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"ltaTime = 0;"],[1,"\nlet frame = 0; // To do something every few frames\nconst targetFPS = 25;"],[0,"\n\n//// Calib"]],"start1":138,"start2":138,"length1":24,"length2":97},{"diffs":[[0,"ame time"],[1,"\n    frame++;"],[0,"\n\n    //"]],"start1":1674,"start2":1674,"length1":16,"length2":29}]},{"type":"edited","filename":"pxt.json","patch":[{"diffs":[[0,"\": \"*\",\n"],[1,"        \"radio\": \"*\",\n        \"microphone\": \"*\",\n"],[0,"        "]],"start1":82,"start2":82,"length1":16,"length2":65},{"diffs":[[0,"1.0\""],[-1,",\n        \"microphone\": \"*\""],[0,"\n   "]],"start1":182,"start2":182,"length1":35,"length2":8}]}]},{"timestamp":1739057128892,"editorVersion":"7.0.57","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"ound"],[-1,"To"],[0,"(1/d"]],"start1":4537,"start2":4537,"length1":10,"length2":8}]}]},{"timestamp":1739057140307,"editorVersion":"7.0.57","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"ound"],[-1,"WithPrecision"],[1,"To"],[0,"(1/d"]],"start1":4537,"start2":4537,"length1":21,"length2":10},{"diffs":[[0,"eltaTime"],[-1,", 2"],[0,").toStri"]],"start1":4547,"start2":4547,"length1":19,"length2":16}]},{"type":"edited","filename":"pxt.json","patch":[{"diffs":[[0,".ts\""],[-1,"\n    ],\n    \"testFiles\": [\n        \"test.ts"],[1,",\n        \"README.md"],[0,"\"\n  "]],"start1":200,"start2":200,"length1":51,"length2":28}]},{"type":"added","filename":"test.ts","value":"// tests go here; this will not be compiled when this package is used as an extension.\n"},{"type":"added","filename":"main.blocks","value":"<xml xmlns=\"http://www.w3.org/1999/xhtml\">\n  <block type=\"pxt-on-start\"></block>\n  <block type=\"device_forever\"></block>\n</xml>"}]}],"snapshots":[{"timestamp":1738802832709,"editorVersion":"7.0.57","text":{"main.ts":"\n","README.md":"","pxt.json":"{\n    \"name\": \"damien\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"radio\": \"*\",\n        \"microphone\": \"*\"\n    },\n    \"files\": [\n        \"main.ts\",\n        \"README.md\"\n    ],\n    \"preferredEditor\": \"tsprj\",\n    \"languageRestriction\": \"javascript-only\",\n    \"additionalFilePaths\": []\n}\n"}},{"timestamp":1738883461159,"editorVersion":"7.0.57","text":{"main.ts":"let lastTime = input.runningTimeMicros() / 1000000;\nlet time = lastTime + 1 / 60;\n\nconst targetFPS = 15;\n\nlet wheelLSpeed = 0;\nlet wheelRSpeed = 0;\n// if going backwards, speed is just regular out of 100, minus 100\n// so 20 backwards is -80\n// 80 backwards is -20\n\nwhile (true){\n    time = input.runningTimeMicros() / 1000000; // Update time\n\n    // XYZ\n    // serial.writeLine(input.acceleration(Dimension.X).toString() + \", \" + input.acceleration(Dimension.Y).toString() + \", \" + input.acceleration(Dimension.Z).toString());\n\n    // Fix the weird thing with negative speeds\n    if (wheelLSpeed < 0){\n        wheelLSpeed = -1 - wheelLSpeed;\n    } if (wheelRSpeed < 0){\n        wheelRSpeed = -1 - wheelRSpeed;\n    }\n    motion.drive(wheelLSpeed * 100, wheelRSpeed * 100);\n\n    lastTime = time;\n    control.waitMicros(Math.max(0, 1 / targetFPS - (input.runningTimeMicros() / 1000000 - time)) * 1000000);\n}\n","README.md":"","pxt.json":"{\n    \"name\": \"damien\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"radio\": \"*\",\n        \"microphone\": \"*\",\n        \"k8\": \"github:k8robotics/pxt-k8#v1.1.0\"\n    },\n    \"files\": [\n        \"main.ts\",\n        \"README.md\"\n    ],\n    \"preferredEditor\": \"tsprj\",\n    \"languageRestriction\": \"javascript-only\"\n}\n"}},{"timestamp":1738970676848,"editorVersion":"7.0.57","text":{"main.ts":"let lastTime = input.runningTimeMicros() / 1000000;\nlet time = lastTime + 1 / 60;\nlet deltaTime = 0;\nconst targetFPS = 20;\n\nlet lSpeed = 0;\nlet rSpeed = 0;\n// if going backwards, speed is just regular out of 100, minus 100\n// so 20 backwards is -80\n// 80 backwards is -20\n\n// let isCountdown = false;\nlet isRunning = false;\nlet isTurning = false;\nlet sonarCounter = 0;\nlet accelerometerCounter = 0;\n// let turningSegment = 0;\n// let countdown = 0;\n\n// let segment = 0;\n\nlet sonarDist = 0;\n\nfunction dotProduct(vector1: Array<number>, vector2: Array<number>) {\n    let result = 0;\n    for (let i = 0; i < vector1.length; i++) {\n        result += vector1[i] * vector2[i];\n    }\n    return result;\n}\n\nwhile(true){\n    time = input.runningTimeMicros() / 1000000; // Update time\n    deltaTime = time - lastTime;\n\n    // XYZ\n    let xA = input.acceleration(Dimension.X);\n    let yA = input.acceleration(Dimension.Y);\n    let zA = input.acceleration(Dimension.Z);\n\n    let upVector = dotProduct([Math.cos(135 / 180 * Math.PI) * zA, Math.sin(135 / 180 * Math.PI) * zA], [Math.cos(135 / 180 * Math.PI) * -yA, Math.sin(135 / 180 * Math.PI) * -yA])\n    serial.writeLine(xA.toString() + \", \" + yA.toString() + \", \" + zA.toString() + \", \" + upVector.toString());\n\n    sonarDist = sonar.checkSonar();\n    sonarDist = sonarDist == 0 ? 150 : sonarDist;\n\n    if (input.buttonIsPressed(Button.A)) {\n        isRunning = false;\n        // isCountdown = false;\n        lSpeed = 0;\n        rSpeed = 0;\n    }\n\n    if (input.buttonIsPressed(Button.B)) {\n        isRunning = true;\n        lSpeed = 0.65;\n        rSpeed = 0.65;\n    }\n\n    if (isRunning){\n        // If it is < 45cm away for 4 ticks in a row, than turning\n        if (!isTurning){\n            if (sonarDist < 45){\n                sonarCounter++;\n                if (sonarCounter > 3){\n                    isTurning = true;\n                    // turningSegment = 0;\n\n                    lSpeed = -0.3;\n                    rSpeed = 0.3;\n\n                    sonarCounter = 0;\n                }\n            } else {\n                sonarCounter = 0;\n            }\n\n\n        }\n\n        // turning parts\n        if (isTurning){\n            // switch (turningSegment){\n            //     case 0:\n                    \n            //         break;\n            //     case 1:\n\n            //         break;\n            //     case 2:\n\n            //         break;\n            //     case 3:\n\n            //         break;\n            // }\n            if (sonarDist > 45){\n                sonarCounter++;\n            }\n\n            if (sonarCounter > 3){\n                isTurning = false;\n                sonarCounter = 0;\n                \n                lSpeed = 0.65;\n                rSpeed = 0.65;\n            }\n        }\n    }\n\n    // square(); // Run turning code stuff\n\n    // Fix the weird thing with negative speeds\n    if (lSpeed < 0) {\n        lSpeed = -1 - lSpeed;\n    } if (rSpeed < 0) {\n        rSpeed = -1 - rSpeed;\n    }\n    motion.drive(lSpeed * 100, rSpeed * 100);\n\n    // no work:\n    // control.waitMicros(Math.round(Math.max(0, 1 / targetFPS - (input.runningTimeMicros() / 1000000 - time)) * 1000000)); // Just be around the fps target\n    lastTime = time;\n}\n\n// function square(){\n//     if (!isRunning) {\n//         if (!isCountdown && input.buttonIsPressed(Button.B)) {\n//             isCountdown = true;\n//             countdown = 2;\n//         } else if (isCountdown) {\n//             countdown -= deltaTime;\n//             if (countdown < 0) {\n//                 isCountdown = false;\n\n//                 countdown = 0.34; // How long it will turn\n\n//                 lSpeed = -0.3;\n//                 rSpeed = 0.3;\n//                 isRunning = true;\n//             }\n//         }\n//     } else {\n//         // is running\n//         countdown -= deltaTime;\n\n//         if (segment % 2 == 0) {\n//             if (countdown < 0) {\n//                 // will become odd, so is turn \n//                 segment++;\n\n//                 countdown = 0.34;\n\n//                 lSpeed = -0.3;\n//                 rSpeed = 0.3;\n//             }\n//         } else {\n//             if (countdown < 0) {\n//                 // will be even, so is straights\n//                 segment++;\n\n//                 countdown = 2;\n\n//                 lSpeed = 0.65;\n//                 rSpeed = 0.65;\n//             }\n//         }\n\n//         if (segment > 7) {\n//             segment = 0;\n//         }\n//     }\n// }","README.md":"","pxt.json":"{\n    \"name\": \"damien\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"radio\": \"*\",\n        \"microphone\": \"*\",\n        \"k8\": \"github:k8robotics/pxt-k8#v1.1.0\"\n    },\n    \"files\": [\n        \"main.ts\",\n        \"README.md\"\n    ],\n    \"preferredEditor\": \"tsprj\",\n    \"languageRestriction\": \"javascript-only\"\n}\n"}},{"timestamp":1739041287705,"editorVersion":"7.0.57","text":{"main.ts":"let lastTime = input.runningTimeMicros() / 1000000;\nlet time = lastTime + 1 / 60;\nlet deltaTime = 0;\nconst targetFPS = 25;\n\nlet lSpeed = 0;\nlet rSpeed = 0;\n// if going backwards, speed is just regular out of 100, minus 100\n// so 20 backwards is -80\n// 80 backwards is -20\n\n// let isCountdown = false;\nlet isRunning = false;\nlet isTurning = false;\nlet sonarCounter = 0;\nlet accelerometerCounter = 0;\n// let turningSegment = 0;\n// let countdown = 0;\n\n// let segment = 0;\n\nlet sonarDist = 0;\n\nwhile(true){\n    time = input.runningTimeMicros() / 1000000; // Update time\n    deltaTime = time - lastTime;\n\n    // XYZ\n    let xA = input.acceleration(Dimension.X);\n    let yA = input.acceleration(Dimension.Y);\n    let zA = input.acceleration(Dimension.Z);\n\n    let upVector = Math.sin(135/180*Math.PI) * (-yA + zA); // Get the vertical mhmm\n    let forwardVector = Math.sin(135/180*Math.PI) * (-yA + -zA); // Positive = acceleration forward\n    // let movementAngle = Math.atan2(upVector)\n\n    serial.writeLine(Math.round(upVector).toString() + \", \" + Math.round(forwardVector).toString());\n\n    sonarDist = sonar.checkSonar();\n    sonarDist = sonarDist == 0 ? 150 : sonarDist;\n\n    if (input.buttonIsPressed(Button.A)) {\n        isRunning = false;\n        // isCountdown = false;\n        lSpeed = 0;\n        rSpeed = 0;\n    }\n\n    if (input.buttonIsPressed(Button.B)) {\n        isRunning = true;\n        lSpeed = 0.65;\n        rSpeed = 0.65;\n    }\n\n    if (isRunning){\n        // If it is < 45cm away for 4 ticks in a row, than turning\n        if (!isTurning){\n            if (sonarDist < 45){\n                sonarCounter++;\n                if (sonarCounter > 3){\n                    isTurning = true;\n                    // turningSegment = 0;\n\n                    lSpeed = -0.3;\n                    rSpeed = 0.3;\n\n                    sonarCounter = 0;\n                }\n            } else {\n                sonarCounter = 0;\n            }\n\n            if (forwardVector < -500){\n                isTurning = true;\n                lSpeed = -0.4;\n                rSpeed = -0.2;\n            }\n        }\n\n        // turning parts\n        if (isTurning){\n            // switch (turningSegment){\n            //     case 0:\n                    \n            //         break;\n            //     case 1:\n\n            //         break;\n            //     case 2:\n\n            //         break;\n            //     case 3:\n\n            //         break;\n            // }\n            if (sonarDist > 45){\n                sonarCounter++;\n            }\n\n            if (sonarCounter > 3){\n                isTurning = false;\n                sonarCounter = 0;\n                \n                lSpeed = 0.65;\n                rSpeed = 0.65;\n            }\n        }\n    }\n\n    // square(); // Run turning code stuff\n\n    // Fix the weird thing with negative speeds\n    if (lSpeed < 0) {\n        lSpeed = -1 - lSpeed;\n    } if (rSpeed < 0) {\n        rSpeed = -1 - rSpeed;\n    }\n    motion.drive(lSpeed * 100, rSpeed * 100);\n\n    // no work:\n    // control.waitMicros(Math.max(0, Math.round(1 / targetFPS - (input.runningTimeMicros() / 1000000 - time)) * 1000000)); // Just be around the fps target\n    lastTime = time;\n}\n\n// function square(){\n//     if (!isRunning) {\n//         if (!isCountdown && input.buttonIsPressed(Button.B)) {\n//             isCountdown = true;\n//             countdown = 2;\n//         } else if (isCountdown) {\n//             countdown -= deltaTime;\n//             if (countdown < 0) {\n//                 isCountdown = false;\n\n//                 countdown = 0.34; // How long it will turn\n\n//                 lSpeed = -0.3;\n//                 rSpeed = 0.3;\n//                 isRunning = true;\n//             }\n//         }\n//     } else {\n//         // is running\n//         countdown -= deltaTime;\n\n//         if (segment % 2 == 0) {\n//             if (countdown < 0) {\n//                 // will become odd, so is turn \n//                 segment++;\n\n//                 countdown = 0.34;\n\n//                 lSpeed = -0.3;\n//                 rSpeed = 0.3;\n//             }\n//         } else {\n//             if (countdown < 0) {\n//                 // will be even, so is straights\n//                 segment++;\n\n//                 countdown = 2;\n\n//                 lSpeed = 0.65;\n//                 rSpeed = 0.65;\n//             }\n//         }\n\n//         if (segment > 7) {\n//             segment = 0;\n//         }\n//     }\n// }","README.md":"","pxt.json":"{\n    \"name\": \"damien\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"radio\": \"*\",\n        \"microphone\": \"*\",\n        \"k8\": \"github:k8robotics/pxt-k8#v1.1.0\"\n    },\n    \"files\": [\n        \"main.ts\",\n        \"README.md\"\n    ],\n    \"preferredEditor\": \"tsprj\",\n    \"languageRestriction\": \"javascript-only\"\n}\n"}},{"timestamp":1739043286152,"editorVersion":"7.0.57","text":{"main.ts":"let lastTime = input.runningTimeMicros() / 1000000;\nlet time = lastTime + 1 / 60;\nlet deltaTime = 0;\nconst targetFPS = 25;\n\nlet lSpeed = 0;\nlet rSpeed = 0;\n// if going backwards, speed is just regular out of 100, minus 100\n// so 20 backwards is -80\n// 80 backwards is -20\n\nlet sonarDist = 0;\nlet upVector = 0;\nlet forwardVector = 0;\n\nlet isCalibrating = true;\nlet calibrationCountdown = 3;\nwhile (isCalibrating){\n    if (input.buttonIsPressed(Button.A)){\n        \n    }\n}\n\nwhile (true){\n    time = input.runningTimeMicros() / 1000000; // Update time\n    deltaTime = time - lastTime;\n\n    // inputs and measurements\n    calculateAcceleration();\n    sonarDist = sonar.checkSonar();\n    sonarDist = sonarDist == 0 ? 150 : sonarDist;\n\n    serial.writeLine(Math.round(upVector).toString() + \", \" + Math.round(forwardVector).toString());\n\n    if (input.buttonIsPressed(Button.B)) {\n        lSpeed = 0;\n        rSpeed = 0;\n    }\n\n    if (input.buttonIsPressed(Button.A)) {\n        lSpeed = 0.65;\n        rSpeed = 0.65;\n    }\n\n    driveMotors();\n\n    // Update for delta time calcualtions\n    lastTime = time;\n}\n\nfunction calculateAcceleration(){\n    let xA = input.acceleration(Dimension.X);\n    let yA = input.acceleration(Dimension.Y);\n    let zA = input.acceleration(Dimension.Z);\n\n    upVector = Math.sin(135 / 180 * Math.PI) * (-yA + zA) + 1024; // Get the vertical velocity (accounting for gravity)\n    forwardVector = Math.sin(135 / 180 * Math.PI) * (-yA + -zA); // Positive = acceleration forward\n    // let movementAngle = Math.atan2(upVector)\n}\n\nfunction driveMotors(){\n    // Calculate the input for the drive function, and drive\n    if (lSpeed < 0) {\n        lSpeed = -1 - lSpeed;\n    } if (rSpeed < 0) {\n        rSpeed = -1 - rSpeed;\n    }\n\n    motion.drive(lSpeed * 100, rSpeed * 100);\n}","README.md":"","pxt.json":"{\n    \"name\": \"damien\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"radio\": \"*\",\n        \"microphone\": \"*\",\n        \"k8\": \"github:k8robotics/pxt-k8#v1.1.0\"\n    },\n    \"files\": [\n        \"main.ts\",\n        \"README.md\"\n    ],\n    \"preferredEditor\": \"tsprj\",\n    \"languageRestriction\": \"javascript-only\"\n}\n"}},{"timestamp":1739045142818,"editorVersion":"7.0.57","text":{"main.ts":"let lastTime = input.runningTimeMicros() / 1000000;\nlet time = lastTime + 1 / 60;\nlet deltaTime = 0;\nconst targetFPS = 25;\n\nlet lSpeed = 0;\nlet rSpeed = 0;\n// if going backwards, speed is just regular out of 100, minus 100\n// so 20 backwards is -80\n// 80 backwards is -20\n\nlet sonarDist = 0;\nlet upVector = 0;\nlet forwardVector = 0;\n\nlet segment = 0; // 0 = calibration, 1 = button drive\nlet calibrationCountdown = 3;\nlet calibrationLoops = 0;\nlet avgForwardVector = 0;\nlet avgUpVector = 0;\nlet forwardVectorOffset = 0;\nlet upVectorOffset = 0;\n\nwhile (true){\n    // Update time\n    time = input.runningTimeMicros() / 1000000;\n    deltaTime = time - lastTime;\n\n    // Inputs and measurements\n    calculateAcceleration();\n    sonarDist = sonar.checkSonar();\n    sonarDist = sonarDist == 0 ? 150 : sonarDist;\n\n    if (segment == 0){\n        if (input.buttonIsPressed(Button.A) && calibrationCountdown == 3) {\n            calibrationCountdown -= deltaTime;\n        } else if (calibrationCountdown != 3){\n            calibrationCountdown -= deltaTime;\n\n            if (calibrationCountdown <= 0){\n                // Calibration!\n                avgForwardVector += forwardVector;\n                avgUpVector += upVector;\n\n                calibrationLoops++;\n\n                if (calibrationLoops > 100){\n                    segment++; // Stops calibrating and moves on\n                    \n                    avgForwardVector /= calibrationLoops;\n                    avgUpVector /= calibrationLoops;\n                    \n                    forwardVectorOffset = -avgForwardVector;\n                    upVectorOffset = -avgUpVector;\n                }\n            }\n        }\n    } else if (segment == 1){\n        if (input.buttonIsPressed(Button.A)) {\n            lSpeed += deltaTime * 0.1;\n            rSpeed = lSpeed;\n        }\n\n        if (input.buttonIsPressed(Button.B)) {\n            lSpeed -= deltaTime * 0.1;\n            rSpeed = lSpeed;\n        }\n    }\n\n    serial.writeLine(segment.toString() + \", \" + Math.roundWithPrecision(lSpeed, 3).toString() + \", \" + Math.roundWithPrecision(upVector, 2).toString() + \", \" + Math.roundWithPrecision(forwardVector, 2).toString());\n\n    driveMotors();\n\n    // Update for delta time calcualtions\n    lastTime = time;\n}\n\nfunction calculateAcceleration(){\n    let xA = input.acceleration(Dimension.X);\n    let yA = input.acceleration(Dimension.Y);\n    let zA = input.acceleration(Dimension.Z);\n\n    upVector = Math.sin(135 / 180 * Math.PI) * (-yA + zA) + 1024 + upVectorOffset; // Get the vertical velocity (accounting for gravity)\n    forwardVector = Math.sin(135 / 180 * Math.PI) * (-yA + -zA) + forwardVectorOffset; // Positive = acceleration forward\n    // let movementAngle = Math.atan2(upVector)\n}\n\nfunction driveMotors(){\n    // Calculate the input for the drive function, and drive\n    if (lSpeed < 0) {\n        lSpeed = -1 - lSpeed;\n    } if (rSpeed < 0) {\n        rSpeed = -1 - rSpeed;\n    }\n\n    motion.drive(lSpeed * 100, rSpeed * 100);\n}","README.md":"","pxt.json":"{\n    \"name\": \"damien\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"radio\": \"*\",\n        \"microphone\": \"*\",\n        \"k8\": \"github:k8robotics/pxt-k8#v1.1.0\"\n    },\n    \"files\": [\n        \"main.ts\",\n        \"README.md\"\n    ],\n    \"preferredEditor\": \"tsprj\",\n    \"languageRestriction\": \"javascript-only\"\n}\n"}},{"timestamp":1739046959693,"editorVersion":"7.0.57","text":{"main.ts":"let lastTime = input.runningTimeMicros() / 1000000;\nlet time = lastTime + 1 / 60;\nlet deltaTime = 0;\nconst targetFPS = 25;\n\nlet lSpeed = 0;\nlet rSpeed = 0;\n// if going backwards, speed is just regular out of 100, minus 100\n// so 20 backwards is -80\n// 80 backwards is -20\n\nlet segment = 0; // 0 = calibration, 1 = button drive\n\n// Calibration variables\nlet calibrationCountdown = 3;\nlet calibrationLoops = 0;\nlet calibAvgForwardVector = 0;\nlet calibAvgUpVector = 0;\n\n// Global variables //\n// Sonar\nlet sonarDist = 0;\n\n// Accelerometer\nlet upVector = 0;\nlet forwardVector = 0;\n\nlet avgForwardVector = 0;\nlet avgUpVector = 0;\n\nlet forwardVectorOffset = 0;\nlet upVectorOffset = 0;\n\nlet vectorsList = [[0, 0, 0, 0], [0, 0 ,0, 0]];\n\n// Position\nlet x = 0;\nlet y = 0;\nlet xVel = 0;\nlet yVel = 0;\n\nwhile (true){\n    // Update time\n    time = input.runningTimeMicros() / 1000000;\n    deltaTime = time - lastTime;\n\n    // Inputs and measurements\n    calculateAcceleration();\n    sonarDist = sonar.checkSonar();\n    sonarDist = sonarDist == 0 ? 150 : sonarDist;\n\n    if (segment == 0){\n        if (input.buttonIsPressed(Button.A) && calibrationCountdown == 3) {\n            calibrationCountdown -= deltaTime;\n        } else if (calibrationCountdown != 3){\n            calibrationCountdown -= deltaTime;\n\n            if (calibrationCountdown <= 0){\n                // Calibration!\n                // Show blinking dot for calibrating\n                if (Math.round(time / 0.7) % 2){\n                    led.plot(1, 0);\n                } else {\n                    led.unplot(1, 0);\n                }\n\n                calibAvgForwardVector += forwardVector;\n                calibAvgUpVector += upVector;\n\n                calibrationLoops++;\n\n                if (calibrationLoops > 50){ // Do 50 (or maybe 51 I don't care) loops\n                    calibAvgForwardVector /= calibrationLoops;\n                    calibAvgUpVector /= calibrationLoops;\n                    \n                    forwardVectorOffset = -calibAvgForwardVector;\n                    upVectorOffset = -calibAvgUpVector;\n\n                    segment++; // Stops calibrating and moves on\n                    led.plot(1, 0); // Light to show calibration done\n                }\n            } else {\n                // show countdown\n                led.plot(3 - Math.round(calibrationCountdown + 0.5) + 2, 0);\n            }\n        } else {\n            // Press button A to calibrate\n            led.plot(0, 0);\n        }\n    } else if (segment == 1){\n        // Running\n        led.plot(0, 1);\n\n        \n    }\n\n    serial.writeLine(Math.roundWithPrecision(avgForwardVector, 2) + \", \" + Math.roundWithPrecision(avgUpVector, 2) + \", \" + segment.toString());\n\n    driveMotors();\n\n    // Update for delta time calcualtions\n    lastTime = time;\n}\n\nfunction calculateAcceleration(){\n    let xA = input.acceleration(Dimension.X);\n    let yA = input.acceleration(Dimension.Y);\n    let zA = input.acceleration(Dimension.Z);\n\n    upVector = Math.sin(135 / 180 * Math.PI) * (-yA + zA) + 1024 + upVectorOffset; // Get the vertical velocity (accounting for gravity)\n    forwardVector = Math.sin(135 / 180 * Math.PI) * (-yA + -zA) + forwardVectorOffset; // Positive = acceleration forward\n    // let movementAngle = Math.atan2(upVector)\n\n    for (let i = 3; i > 0; i -= 1){\n        vectorsList[0][i] = vectorsList[0][i - 1]\n        vectorsList[1][i] = vectorsList[1][i - 1]\n    }\n\n    vectorsList[0][0] = forwardVector;\n    vectorsList[1][0] = upVector;\n\n    avgForwardVector = 0;\n    avgUpVector = 0;\n\n    for (let i = 0; i < 4; i++){\n        avgForwardVector += vectorsList[0][i];\n        avgUpVector += vectorsList[1][i];\n    }\n    avgForwardVector /= 4;\n    avgUpVector /= 4;\n}\n\nfunction driveMotors(){\n    // Calculate the input for the drive function, and drive\n    if (lSpeed < 0) {\n        lSpeed = -1 - lSpeed;\n    } if (rSpeed < 0) {\n        rSpeed = -1 - rSpeed;\n    }\n\n    motion.drive(lSpeed * 100, rSpeed * 100);\n}","README.md":"","pxt.json":"{\n    \"name\": \"damien\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"radio\": \"*\",\n        \"microphone\": \"*\",\n        \"k8\": \"github:k8robotics/pxt-k8#v1.1.0\"\n    },\n    \"files\": [\n        \"main.ts\",\n        \"README.md\"\n    ],\n    \"preferredEditor\": \"tsprj\",\n    \"languageRestriction\": \"javascript-only\"\n}\n"}},{"timestamp":1739048890420,"editorVersion":"7.0.57","text":{"main.ts":"let lastTime = input.runningTimeMicros() / 1000000;\nlet time = lastTime + 1 / 60;\nlet deltaTime = 0;\nlet frame = 0; // To do something every few frames\nconst targetFPS = 25;\n\nlet lSpeed = 0;\nlet rSpeed = 0;\n// if going backwards, speed is just regular out of 100, minus 100\n// so 20 backwards is -80\n// 80 backwards is -20\n\nlet segment = 0; // 0 = calibration, 1 = button drive\n\n// Calibration variables\nlet calibrationCountdown = 3;\nlet calibrationLoops = 0;\nlet calibrationsToDo = 0;\nlet calibAvgForwardVector = 0;\nlet calibAvgUpVector = 0;\nlet calibAvgXVector = 0;\n\n// Global variables //\n// Sonar\nlet sonarDist = 0;\n\n// Accelerometer\nlet forwardVector = 0;\nlet upVector = 0;\nlet xVector = 0;\n\nlet avgForwardVector = 0;\nlet avgUpVector = 0;\nlet avgXVector = 0;\n\nlet forwardVectorOffset = 0;\nlet upVectorOffset = 0;\nlet xVectorOffset = 0;\n\nlet vectorsList = [[0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0]];\n\n// Position\nlet x = 0;\nlet y = 0;\nlet xVel = 0;\nlet yVel = 0;\n\nwhile (true){\n    // Update time\n    time = input.runningTimeMicros() / 1000000;\n    deltaTime = time - lastTime;\n    frame++;\n\n    // Inputs and measurements\n    calculateAcceleration();\n    // sonarDist = sonar.checkSonar();\n    // sonarDist = sonarDist == 0 ? 150 : sonarDist;\n\n    if (segment == 0){\n        if (input.buttonIsPressed(Button.A) && calibrationCountdown == 3) {\n            calibrationCountdown -= deltaTime;\n            calibrationsToDo = Math.round(1 / deltaTime) * 3; // 3 seconds worth\n        } else if (calibrationCountdown != 3){\n            calibrationCountdown -= deltaTime;\n\n            if (calibrationCountdown <= 0){\n                // Calibration!\n                // Show blinking dot for calibrating\n                if (Math.round(time / 0.7) % 2){\n                    led.plot(1, 0);\n                } else {\n                    led.unplot(1, 0);\n                }\n\n                calibAvgForwardVector += forwardVector;\n                calibAvgUpVector += upVector;\n                calibAvgXVector += xVector;\n\n                calibrationLoops++;\n\n                if (calibrationLoops > calibrationsToDo){ // Do 3 second's worth of loops\n                    calibAvgForwardVector /= calibrationLoops;\n                    calibAvgUpVector /= calibrationLoops;\n                    calibAvgXVector /= calibrationLoops;\n                    \n                    forwardVectorOffset = -calibAvgForwardVector;\n                    upVectorOffset = -calibAvgUpVector;\n                    xVectorOffset = -calibAvgXVector;\n\n                    segment++; // Stops calibrating and moves on\n                    led.plot(1, 0); // Light to show calibration done\n                }\n            } else {\n                // show countdown\n                led.plot(3 - Math.round(calibrationCountdown + 0.5) + 2, 0);\n            }\n        } else {\n            // Press button A to calibrate\n            led.plot(0, 0);\n        }\n    } else if (segment == 1){\n        // Running\n\n        \n    }\n\n    // serial.writeLine(Math.roundWithPrecision(avgForwardVector, 2) + \", \" + Math.roundWithPrecision(avgUpVector, 2) + \", \" + Math.roundWithPrecision(avgXVector, 2) + \", \" + segment.toString());\n    if (frame % 60 == 0){\n        serial.writeLine(Math.round(1/deltaTime).toString() + \", \" + Math.roundWithPrecision(x, 3).toString() + \", \" + Math.roundWithPrecision(y, 3).toString());\n    }\n\n    // driveMotors();\n\n    // Update for delta time calcualtions\n    control.waitMicros(1000000/400);\n    lastTime = time;\n}\n\nfunction calculateAcceleration(){\n    let xA = input.acceleration(Dimension.X);\n    let yA = input.acceleration(Dimension.Y);\n    let zA = input.acceleration(Dimension.Z);\n\n    upVector = Math.sin(135 / 180 * Math.PI) * (-yA + zA) + 1024 + upVectorOffset; // Get the vertical velocity (accounting for gravity)\n    forwardVector = Math.sin(135 / 180 * Math.PI) * (-yA + -zA) + forwardVectorOffset; // Positive = acceleration forward\n    xVector = xA + xVectorOffset;\n    // let movementAngle = Math.atan2(upVector)\n\n    for (let i = 3; i > 0; i -= 1){\n        vectorsList[0][i] = vectorsList[0][i - 1]\n        vectorsList[1][i] = vectorsList[1][i - 1]\n        vectorsList[2][i] = vectorsList[2][i - 1]\n    }\n\n    vectorsList[0][0] = forwardVector;\n    vectorsList[1][0] = upVector;\n    vectorsList[2][0] = xA;\n\n    avgForwardVector = 0;\n    avgUpVector = 0;\n    avgXVector = 0;\n\n    for (let i = 0; i < 4; i++){\n        avgForwardVector += vectorsList[0][i];\n        avgUpVector += vectorsList[1][i];\n        avgXVector += vectorsList[2][i];\n    }\n    avgForwardVector /= 4;\n    avgUpVector /= 4;\n    avgXVector /= 4;\n}\n\nfunction driveMotors(){\n    // Calculate the input for the drive function, and drive\n    if (lSpeed < 0) {\n        lSpeed = -1 - lSpeed;\n    } if (rSpeed < 0) {\n        rSpeed = -1 - rSpeed;\n    }\n\n    motion.drive(lSpeed * 100, rSpeed * 100);\n}","README.md":"","pxt.json":"{\n    \"name\": \"damien\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"radio\": \"*\",\n        \"microphone\": \"*\",\n        \"k8\": \"github:k8robotics/pxt-k8#v1.1.0\"\n    },\n    \"files\": [\n        \"main.ts\",\n        \"README.md\"\n    ],\n    \"preferredEditor\": \"tsprj\",\n    \"languageRestriction\": \"javascript-only\"\n}\n"}},{"timestamp":1739053270765,"editorVersion":"7.0.57","text":{"main.ts":"let lastTime = input.runningTimeMicros() / 1000000;\nlet time = lastTime + 1 / 60;\nlet deltaTime = 0;\nlet frame = 0; // To do something every few frames\nconst targetFPS = 25;\n\nlet lSpeed = 0;\nlet rSpeed = 0;\n// if going backwards, speed is just regular out of 100, minus 100\n// so 20 backwards is -80\n// 80 backwards is -20\n\nlet segment = 0; // 0 = calibration, 1 = button drive\n\n// Calibration variables\nlet calibrationCountdown = 3;\nlet calibrationLoops = 0;\nlet calibrationsToDo = 0;\nlet calibAvgForwardVector = 0;\nlet calibAvgUpVector = 0;\nlet calibAvgXVector = 0;\n\n// Global variables //\n// Sonar\nlet sonarDist = 0;\n\n// Accelerometer\nlet forwardVector = 0;\nlet upVector = 0;\nlet xVector = 0;\n\nlet avgForwardVector = 0;\nlet avgUpVector = 0;\nlet avgXVector = 0;\n\nlet forwardVectorOffset = 0;\nlet upVectorOffset = 0;\nlet xVectorOffset = 0;\n\nlet vectorsList = [[0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0]];\n\n// Position\nlet x = 0;\nlet y = 0;\nlet xVel = 0;\nlet yVel = 0;\nlet rotation = 0; // in radians, 0deg = positive x (cos(a)*m = x, sin(a)*m = y)\n\nwhile (true){\n    // Update time\n    time = input.runningTimeMicros() / 1000000;\n    deltaTime = time - lastTime;\n    frame++;\n\n    // Inputs and measurements\n    calculateAcceleration();\n    sonarDist = sonar.checkSonar();\n    sonarDist = sonarDist == 0 ? 150 : sonarDist;\n\n    if (segment == 0){\n        if (input.buttonIsPressed(Button.A) && calibrationCountdown == 3) {\n            calibrationCountdown -= deltaTime;\n            calibrationsToDo = Math.round(1 / deltaTime) * 3; // 3 seconds worth\n        } else if (calibrationCountdown != 3){\n            calibrationCountdown -= deltaTime;\n\n            if (calibrationCountdown <= 0){\n                // Calibration!\n                // Show blinking dot for calibrating\n                if (Math.round(time / 0.7) % 2){\n                    led.plot(1, 0);\n                } else {\n                    led.unplot(1, 0);\n                }\n\n                calibAvgForwardVector += forwardVector;\n                calibAvgUpVector += upVector;\n                calibAvgXVector += xVector;\n\n                calibrationLoops++;\n\n                if (calibrationLoops > calibrationsToDo){ // Do 3 second's worth of loops\n                    calibAvgForwardVector /= calibrationLoops;\n                    calibAvgUpVector /= calibrationLoops;\n                    calibAvgXVector /= calibrationLoops;\n                    \n                    forwardVectorOffset = -calibAvgForwardVector;\n                    upVectorOffset = -calibAvgUpVector;\n                    xVectorOffset = -calibAvgXVector;\n\n                    segment++; // Stops calibrating and moves on\n                    led.plot(1, 0); // Light to show calibration done\n                }\n            } else {\n                // show countdown\n                led.plot(3 - Math.round(calibrationCountdown + 0.5) + 2, 0);\n            }\n        } else {\n            // Press button A to calibrate\n            led.plot(0, 0);\n        }\n    } else if (segment == 1){\n        // Running\n\n        lSpeed = 0.6;\n        rSpeed = 0.6;\n\n        if (sonarDist < 50){\n            lSpeed = -0.3;\n            rSpeed = 0.3;\n\n    //         // 1.36s? for a full rotation\n    //         rotation += -deltaTime/1.36 * 2 * Math.PI; // 360 degress in 1.36 seconds\n    //     } else {\n    //         x += lSpeed * Math.cos(rotation);\n    //         y += lSpeed * Math.sin(rotation);\n    //     }\n        }\n    }\n\n    // serial.writeLine(Math.roundWithPrecision(avgForwardVector, 2) + \", \" + Math.roundWithPrecision(avgUpVector, 2) + \", \" + Math.roundWithPrecision(avgXVector, 2) + \", \" + segment.toString());\n    if (frame % Math.round((1 / deltaTime) / 4) == 0){ // 4 times per second, serial\n        serial.writeLine(Math.round(1/deltaTime).toString() + \"fps, \" + Math.roundWithPrecision(x, 3).toString() + \", \" + Math.roundWithPrecision(y, 3).toString());\n    }\n\n    driveMotors();\n\n    // Update for delta time calcualtions\n    control.waitMicros(1000000/400);\n    lastTime = time;\n}\n\nfunction calculateAcceleration(){\n    let xA = input.acceleration(Dimension.X);\n    let yA = input.acceleration(Dimension.Y);\n    let zA = input.acceleration(Dimension.Z);\n\n    upVector = Math.sin(135 / 180 * Math.PI) * (-yA + zA) + 1024 + upVectorOffset; // Get the vertical velocity (accounting for gravity)\n    forwardVector = Math.sin(135 / 180 * Math.PI) * (-yA + -zA) + forwardVectorOffset; // Positive = acceleration forward\n    xVector = xA + xVectorOffset;\n    // let movementAngle = Math.atan2(upVector)\n\n    for (let i = 3; i > 0; i -= 1){\n        vectorsList[0][i] = vectorsList[0][i - 1]\n        vectorsList[1][i] = vectorsList[1][i - 1]\n        vectorsList[2][i] = vectorsList[2][i - 1]\n    }\n\n    vectorsList[0][0] = forwardVector;\n    vectorsList[1][0] = upVector;\n    vectorsList[2][0] = xA;\n\n    avgForwardVector = 0;\n    avgUpVector = 0;\n    avgXVector = 0;\n\n    for (let i = 0; i < 4; i++){\n        avgForwardVector += vectorsList[0][i];\n        avgUpVector += vectorsList[1][i];\n        avgXVector += vectorsList[2][i];\n    }\n    avgForwardVector /= 4;\n    avgUpVector /= 4;\n    avgXVector /= 4;\n}\n\nfunction driveMotors(){\n    // Calculate the input for the drive function, and drive\n    if (lSpeed < 0) {\n        lSpeed = -1 - lSpeed;\n    } if (rSpeed < 0) {\n        rSpeed = -1 - rSpeed;\n    }\n\n    motion.drive(lSpeed * 100, rSpeed * 100);\n}","README.md":"","pxt.json":"{\n    \"name\": \"damien\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"radio\": \"*\",\n        \"microphone\": \"*\",\n        \"k8\": \"github:k8robotics/pxt-k8#v1.1.0\"\n    },\n    \"files\": [\n        \"main.ts\",\n        \"README.md\"\n    ],\n    \"preferredEditor\": \"tsprj\",\n    \"languageRestriction\": \"javascript-only\"\n}\n"}},{"timestamp":1739055085189,"editorVersion":"7.0.57","text":{"main.ts":"// Variables for time, delta time, and fps\nlet lastTime = input.runningTimeMicros() / 1000000;\nlet time = lastTime + 1 / 60;\nlet deltaTime = 0;\nlet frame = 0; // To do something every few frames\nconst targetFPS = 25;\n\n// Global variables //\n// Calibration variables\nlet isCalibrating = false;\nconst calibrationSamples = 50;\nlet calibrationCountdown = 3;\nlet calibrationSamplesDone = 0;\nlet calibAvgForwardVector = 0;\nlet calibAvgUpVector = 0;\nlet calibAvgXVector = 0;\n\n// Segment\nlet segment = 0; // 0 = calibration, 1 = button drive\n\n// Motors\nlet lSpeed = 0;\nlet rSpeed = 0;\n\n// Sonar\nlet sonarDist = 0;\n\n// Accelerometer\nlet forwardVector = 0;\nlet upVector = 0;\nlet xVector = 0;\n\nlet avgForwardVector = 0;\nlet avgUpVector = 0;\nlet avgXVector = 0;\n\nlet forwardVectorOffset = 0;\nlet upVectorOffset = 0;\nlet xVectorOffset = 0;\n\nlet vectorsList = [[0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0]];\n\n// Position\nlet x = 0;\nlet y = 0;\nlet xVel = 0;\nlet yVel = 0;\nlet rotation = 0; // in radians, 0deg = positive x (cos(a)*m = x, sin(a)*m = y)\n\nwhile (true){\n    // Update time, delta time, and frame number\n    time = input.runningTimeMicros() / 1000000;\n    deltaTime = time - lastTime;\n    frame++;\n\n    // Update sonar and acceleration measurements\n    calculateAcceleration(); // Function that updates acceleration and the vectors\n    sonarDist = sonar.checkSonar(); // Get output, max of 150\n    // sonarDist = sonarDist == 0 ? 150 : sonarDist; // This would make it 150 if = 0\n\n    // Handle each segment\n    if (segment == 0){ // Calibration/wait for calibration\n        if (!isCalibrating && input.buttonIsPressed(Button.A)) { // If not calibrating, and A is pressed\n            isCalibrating = true; // Start calibrating\n        } \n        \n        if (isCalibrating){ // Basically, if the button was pressed\n            if (calibrationCountdown > 0){ // If the countdown hasn't reached zero\n                calibrationCountdown -= deltaTime; // Increment calibration countdown\n                led.plot(3 - Math.round(calibrationCountdown + 0.5) + 2, 0); // Show countdown as 3 dots\n            } else { // Countdown complete, and calibration is happening\n                // Show blinking dot for calibrating\n                if (Math.round(time / 0.5) % 2) { // Fancy math to blink every 0.5 seconds\n                    led.plot(1, 0);\n                } else {\n                    led.unplot(1, 0);\n                }\n\n                // Add a sample to the average\n                calibAvgForwardVector += forwardVector;\n                calibAvgUpVector += upVector;\n                calibAvgXVector += xVector;\n\n                // Keep track of how many calibration samples added\n                calibrationSamplesDone++;\n\n                if (calibrationSamplesDone >= calibrationSamples) { // If we have done the number of samples we need, than divide to get the average\n                    calibAvgForwardVector /= calibrationSamplesDone;\n                    calibAvgUpVector /= calibrationSamplesDone;\n                    calibAvgXVector /= calibrationSamplesDone;\n\n                    // The average is the offset we need to correct for\n                    forwardVectorOffset = -calibAvgForwardVector;\n                    upVectorOffset = -calibAvgUpVector;\n                    xVectorOffset = -calibAvgXVector;\n\n                    segment++; // Goes to the next part of execution (\"Running\")\n                    led.plot(1, 0); // Light to show that calibration's done\n                }\n            }\n        } else { // Not calibrating\n            led.plot(0, 0); // Just turn on the led\n        }\n    } else if (segment == 1){\n        // Running\n        lSpeed = 0.6;\n        rSpeed = 0.6;\n\n        if (sonarDist < 50){\n            // Turn left\n            lSpeed = -0.3;\n            rSpeed = 0.3;\n\n            // Show led turning left\n            led.plot(4, 2);\n            led.unplot(2, 2);\n        } else {\n            // Show led center\n            led.plot(2, 2);\n            led.unplot(4, 2);\n        }\n    }\n\n     // 4 times per second, write something to serial\n    if (frame % Math.round((1 / deltaTime) / 4) == 0){\n        serial.writeLine(Math.round(1/deltaTime).toString() + \"fps\");\n        // Prints fps\n    }\n\n    driveMotors(); // Takes lSpeed and rSpeed and makes the motors turn\n\n    // Update for delta time calcualtions\n    lastTime = time;\n}\n\n// This takes the raw acceleration and turns it into vectors (up, forward, and x (which is right/left))\nfunction calculateAcceleration(){\n    let xA = input.acceleration(Dimension.X);\n    let yA = input.acceleration(Dimension.Y);\n    let zA = input.acceleration(Dimension.Z);\n\n    // Fancy maths\n    upVector = Math.sin(135 / 180 * Math.PI) * (-yA + zA) + 1024 + upVectorOffset; // Get the vertical velocity (accounting for gravity 1024)\n    forwardVector = Math.sin(135 / 180 * Math.PI) * (-yA + -zA) + forwardVectorOffset; // Positive = acceleration forward\n    xVector = xA + xVectorOffset; // Side to side acceleration\n\n    // Shift the list of vectors so that \n    for (let i = 3; i > 0; i -= 1){\n        vectorsList[0][i] = vectorsList[0][i - 1]\n        vectorsList[1][i] = vectorsList[1][i - 1]\n        vectorsList[2][i] = vectorsList[2][i - 1]\n    }\n\n    vectorsList[0][0] = forwardVector;\n    vectorsList[1][0] = upVector;\n    vectorsList[2][0] = xA;\n\n    avgForwardVector = 0;\n    avgUpVector = 0;\n    avgXVector = 0;\n\n    for (let i = 0; i < 4; i++){\n        avgForwardVector += vectorsList[0][i];\n        avgUpVector += vectorsList[1][i];\n        avgXVector += vectorsList[2][i];\n    }\n    avgForwardVector /= 4;\n    avgUpVector /= 4;\n    avgXVector /= 4;\n}\n\nfunction driveMotors(){\n    // Calculate the input for the drive function, and drive\n    if (lSpeed < 0) {\n        lSpeed = -1 - lSpeed;\n    } if (rSpeed < 0) {\n        rSpeed = -1 - rSpeed;\n    }\n\n    motion.drive(lSpeed * 100, rSpeed * 100);\n}","README.md":"","pxt.json":"{\n    \"name\": \"damien\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"radio\": \"*\",\n        \"microphone\": \"*\",\n        \"k8\": \"github:k8robotics/pxt-k8#v1.1.0\"\n    },\n    \"files\": [\n        \"main.ts\",\n        \"README.md\"\n    ],\n    \"preferredEditor\": \"tsprj\",\n    \"languageRestriction\": \"javascript-only\"\n}\n"}},{"timestamp":1739057128176,"editorVersion":"7.0.57","text":{"main.ts":"//// Variables for time, delta time, and fps ////\nlet lastTime = input.runningTimeMicros() / 1000000;\nlet time = lastTime + 1 / 60;\nlet deltaTime = 0;\n\n//// Calibration variables ////\nlet isCalibrating = false;\nconst calibrationSamples = 50;\nlet calibrationCountdown = 3;\nlet calibrationSamplesDone = 0;\n\n// Used as temporary variables to add for each sample, which are then divided by the number of samples to get the average\nlet calibAvgForwardVector = 0;\nlet calibAvgUpVector = 0;\nlet calibAvgXVector = 0;\n\n// Segment\nlet segment = 0; // 0 = calibration, 1 = button drive\nconst CALIBRATING = 0;\nconst RUNNING = 1;\n\n// Motors speed\nlet lSpeed = 0; // Left motor speed (between -1 and 1)\nlet rSpeed = 0; // Right motor speed (between -1 and 1)\n\n// Sonar\nlet sonarDist = 0;\n\n//// Accelerometer ////\nlet forwardVector = 0;\nlet upVector = 0;\nlet xVector = 0;\n\n// This updates every frame - it's the average of the last 4\nlet avgForwardVector = 0;\nlet avgUpVector = 0;\nlet avgXVector = 0;\n\n// These are used to keep it calibrated\nlet forwardVectorOffset = 0;\nlet upVectorOffset = 0;\nlet xVectorOffset = 0;\n\n// This stores the last 4 of each vector\nlet vectorsList = [[0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0]];\n\n// Not doing position right now\n// // Position\n// let x = 0;\n// let y = 0;\n// let xVel = 0;\n// let yVel = 0;\n// let rotation = 0; // in radians, 0deg = positive x (cos(a)*m = x, sin(a)*m = y)\n\nwhile (true){\n    // Update time, delta time, and frame number\n    time = input.runningTimeMicros() / 1000000; // This is the current time in seconds\n    deltaTime = time - lastTime; // This is the frame time\n\n    // Update sonar and acceleration measurements\n    calculateAcceleration(); // Function that updates acceleration and the vectors\n    sonarDist = sonar.checkSonar(); // Get output, max of 150\n    sonarDist = sonarDist == 0 ? 150 : sonarDist; // This makes it = 150 if sonarDist = 0\n\n    // Handle each segment\n    if (segment == CALIBRATING){ // Calibration/wait for calibration\n        if (!isCalibrating && input.buttonIsPressed(Button.A)) { // If not calibrating, and A is pressed\n            isCalibrating = true; // Start calibrating\n        } \n        \n        if (isCalibrating){\n            if (calibrationCountdown > 0){ // If the countdown hasn't reached zero\n                calibrationCountdown -= deltaTime; // Increment calibration countdown\n                led.plot(3 - Math.round(calibrationCountdown + 0.5) + 2, 0); // Show countdown as 3 dots\n            }\n            else { // Countdown complete, and calibration is happening\n                // Show blinking dot for calibrating\n                if (Math.round(time / 0.5) % 2) { // Fancy math to blink every 0.5 seconds\n                    led.plot(1, 0);\n                } else {\n                    led.unplot(1, 0);\n                }\n\n                // Add a sample to the average\n                calibAvgForwardVector += forwardVector;\n                calibAvgUpVector += upVector;\n                calibAvgXVector += xVector;\n\n                // Keep track of how many calibration samples added\n                calibrationSamplesDone++;\n\n                // If we have done the number of samples we need, than divide to get the average\n                if (calibrationSamplesDone >= calibrationSamples) {\n                    calibAvgForwardVector /= calibrationSamplesDone;\n                    calibAvgUpVector /= calibrationSamplesDone;\n                    calibAvgXVector /= calibrationSamplesDone;\n\n                    // The average is the offset we need to correct for\n                    forwardVectorOffset = -calibAvgForwardVector;\n                    upVectorOffset = -calibAvgUpVector;\n                    xVectorOffset = -calibAvgXVector;\n\n                    segment++; // Goes to the next part of execution (\"Running\")\n                    led.plot(1, 0); // Light to show that calibration's done\n                }\n            }\n        }\n        else { // Not calibrating\n            led.plot(0, 0); // Just turn on the led\n        }\n    } else if (segment == RUNNING){\n        if (sonarDist < 50){\n            // Turn left\n            // lSpeed = -0.3;\n            // rSpeed = 0.3;\n\n            // Show led turning left\n            led.plot(4, 2);\n            led.unplot(2, 2);\n        } else {\n            // Go forward\n            // lSpeed = 0.3;\n            // rSpeed = 0.3;\n\n            // Show led center\n            led.plot(2, 2);\n            led.unplot(4, 2);\n        }\n    }\n\n    // Print to serial\n    serial.writeLine(Math.round(1/deltaTime).toString() + \"fps, \" + sonarDist.toString());\n\n    driveMotors(); // Takes lSpeed and rSpeed and makes the motors turn\n\n    // Update for delta time calcualtions\n    lastTime = time;\n}\n\n\n// This takes the raw acceleration and turns it into vectors (up, forward, and x (which is right/left))\nfunction calculateAcceleration(){\n    let xA = input.acceleration(Dimension.X);\n    let yA = input.acceleration(Dimension.Y);\n    let zA = input.acceleration(Dimension.Z);\n\n    // Fancy maths\n    upVector = Math.sin(135 / 180 * Math.PI) * (-yA + zA) + 1024 + upVectorOffset; // Get the vertical velocity (accounting for gravity 1024)\n    forwardVector = Math.sin(135 / 180 * Math.PI) * (-yA + -zA) + forwardVectorOffset; // Positive = acceleration forward\n    xVector = xA + xVectorOffset; // Side to side acceleration\n\n    // Shift the list of vectors so that you can update the first one\n    for (let i = 3; i > 0; i -= 1){\n        vectorsList[0][i] = vectorsList[0][i - 1]\n        vectorsList[1][i] = vectorsList[1][i - 1]\n        vectorsList[2][i] = vectorsList[2][i - 1]\n    }\n\n    vectorsList[0][0] = forwardVector;\n    vectorsList[1][0] = upVector;\n    vectorsList[2][0] = xA;\n\n    // Find the average of each of the last 4 vectors\n    avgForwardVector = 0;\n    avgUpVector = 0;\n    avgXVector = 0;\n\n    for (let i = 0; i < 4; i++){\n        avgForwardVector += vectorsList[0][i];\n        avgUpVector += vectorsList[1][i];\n        avgXVector += vectorsList[2][i];\n    }\n    avgForwardVector /= 4;\n    avgUpVector /= 4;\n    avgXVector /= 4;\n}\n\n// Calculate the input for the drive function, and drive\nfunction driveMotors(){\n    if (lSpeed < 0) {\n        lSpeed = -1 - lSpeed;\n    } if (rSpeed < 0) {\n        rSpeed = -1 - rSpeed;\n    }\n\n    motion.drive(lSpeed * 100, rSpeed * 100);\n}","README.md":"","pxt.json":"{\n    \"name\": \"damien\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"k8\": \"github:k8robotics/pxt-k8#v1.1.0\",\n        \"microphone\": \"*\"\n    },\n    \"files\": [\n        \"main.ts\",\n        \"README.md\"\n    ],\n    \"preferredEditor\": \"tsprj\",\n    \"languageRestriction\": \"javascript-only\"\n}\n"}}],"shares":[{"id":"71651-33674-61155-20185","timestamp":1739053477572},{"id":"94787-79543-22876-48586","timestamp":1739055937097},{"id":"93826-99851-34251-22525","timestamp":1739056059422}],"lastSaveTime":1739057723798}